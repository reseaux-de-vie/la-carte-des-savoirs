{"ast":null,"code":"import _objectSpread from \"/home/jean-daniel/Documents/Projets/D\\xE9veloppement/ActivityPods/BCM/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";\nimport _asyncToGenerator from \"/home/jean-daniel/Documents/Projets/D\\xE9veloppement/ActivityPods/BCM/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = \"function\" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || \"@@iterator\", asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\", toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, \"\"); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, \"_invoke\", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: \"normal\", arg: fn.call(obj, arg) }; } catch (err) { return { type: \"throw\", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { [\"next\", \"throw\", \"return\"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if (\"throw\" !== record.type) { var result = record.arg, value = result.value; return value && \"object\" == typeof value && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke(\"next\", value, resolve, reject); }, function (err) { invoke(\"throw\", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke(\"throw\", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, \"_invoke\", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = \"suspendedStart\"; return function (method, arg) { if (\"executing\" === state) throw new Error(\"Generator is already running\"); if (\"completed\" === state) { if (\"throw\" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) { if (\"suspendedStart\" === state) throw state = \"completed\", context.arg; context.dispatchException(context.arg); } else \"return\" === context.method && context.abrupt(\"return\", context.arg); state = \"executing\"; var record = tryCatch(innerFn, self, context); if (\"normal\" === record.type) { if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, \"throw\" === methodName && delegate.iterator.return && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method) || \"return\" !== methodName && (context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a '\" + methodName + \"' method\")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = \"normal\", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: \"root\" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if (\"function\" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, \"constructor\", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, \"constructor\", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) { var ctor = \"function\" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, \"toString\", function () { return \"[object Generator]\"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if (\"throw\" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if (\"root\" === entry.tryLoc) return handle(\"end\"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, \"catchLoc\"), hasFinally = hasOwn.call(entry, \"finallyLoc\"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error(\"try statement without catch or finally\"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if (\"throw\" === record.type) throw record.arg; return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if (\"throw\" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\nimport { PluginKey, Plugin } from 'prosemirror-state';\nimport { DecorationSet, Decoration } from 'prosemirror-view';\nimport { escapeForRegEx } from '@tiptap/core';\nfunction findSuggestionMatch(config) {\n  var _a;\n  var char = config.char,\n    allowSpaces = config.allowSpaces,\n    allowedPrefixes = config.allowedPrefixes,\n    startOfLine = config.startOfLine,\n    $position = config.$position;\n  var escapedChar = escapeForRegEx(char);\n  var suffix = new RegExp(\"\\\\s\".concat(escapedChar, \"$\"));\n  var prefix = startOfLine ? '^' : '';\n  var regexp = allowSpaces ? new RegExp(\"\".concat(prefix).concat(escapedChar, \".*?(?=\\\\s\").concat(escapedChar, \"|$)\"), 'gm') : new RegExp(\"\".concat(prefix, \"(?:^)?\").concat(escapedChar, \"[^\\\\s\").concat(escapedChar, \"]*\"), 'gm');\n  var text = ((_a = $position.nodeBefore) === null || _a === void 0 ? void 0 : _a.isText) && $position.nodeBefore.text;\n  if (!text) {\n    return null;\n  }\n  var textFrom = $position.pos - text.length;\n  var match = Array.from(text.matchAll(regexp)).pop();\n  if (!match || match.input === undefined || match.index === undefined) {\n    return null;\n  }\n  // JavaScript doesn't have lookbehinds. This hacks a check that first character\n  // is a space or the start of the line\n  var matchPrefix = match.input.slice(Math.max(0, match.index - 1), match.index);\n  var matchPrefixIsAllowed = new RegExp(\"^[\".concat(allowedPrefixes === null || allowedPrefixes === void 0 ? void 0 : allowedPrefixes.join(''), \"\\0]?$\")).test(matchPrefix);\n  if (allowedPrefixes !== null && !matchPrefixIsAllowed) {\n    return null;\n  }\n  // The absolute position of the match in the document\n  var from = textFrom + match.index;\n  var to = from + match[0].length;\n  // Edge case handling; if spaces are allowed and we're directly in between\n  // two triggers\n  if (allowSpaces && suffix.test(text.slice(to - 1, to + 1))) {\n    match[0] += ' ';\n    to += 1;\n  }\n  // If the $position is located within the matched substring, return that range\n  if (from < $position.pos && to >= $position.pos) {\n    return {\n      range: {\n        from: from,\n        to: to\n      },\n      query: match[0].slice(char.length),\n      text: match[0]\n    };\n  }\n  return null;\n}\nvar SuggestionPluginKey = new PluginKey('suggestion');\nfunction Suggestion(_ref) {\n  var _ref$pluginKey = _ref.pluginKey,\n    pluginKey = _ref$pluginKey === void 0 ? SuggestionPluginKey : _ref$pluginKey,\n    editor = _ref.editor,\n    _ref$char = _ref.char,\n    char = _ref$char === void 0 ? '@' : _ref$char,\n    _ref$allowSpaces = _ref.allowSpaces,\n    allowSpaces = _ref$allowSpaces === void 0 ? false : _ref$allowSpaces,\n    _ref$allowedPrefixes = _ref.allowedPrefixes,\n    allowedPrefixes = _ref$allowedPrefixes === void 0 ? [' '] : _ref$allowedPrefixes,\n    _ref$startOfLine = _ref.startOfLine,\n    startOfLine = _ref$startOfLine === void 0 ? false : _ref$startOfLine,\n    _ref$decorationTag = _ref.decorationTag,\n    decorationTag = _ref$decorationTag === void 0 ? 'span' : _ref$decorationTag,\n    _ref$decorationClass = _ref.decorationClass,\n    decorationClass = _ref$decorationClass === void 0 ? 'suggestion' : _ref$decorationClass,\n    _ref$command = _ref.command,\n    _command = _ref$command === void 0 ? function () {\n      return null;\n    } : _ref$command,\n    _ref$items = _ref.items,\n    items = _ref$items === void 0 ? function () {\n      return [];\n    } : _ref$items,\n    _ref$render = _ref.render,\n    render = _ref$render === void 0 ? function () {\n      return {};\n    } : _ref$render,\n    _ref$allow = _ref.allow,\n    allow = _ref$allow === void 0 ? function () {\n      return true;\n    } : _ref$allow;\n  var props;\n  var renderer = render === null || render === void 0 ? void 0 : render();\n  var plugin = new Plugin({\n    key: pluginKey,\n    view: function view() {\n      var _this = this;\n      return {\n        update: function () {\n          var _update = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(view, prevState) {\n            var _a, _b, _c, _d, _e, _f, _g, prev, next, moved, started, stopped, changed, handleStart, handleChange, handleExit, state, decorationNode;\n            return _regeneratorRuntime().wrap(function _callee$(_context) {\n              while (1) switch (_context.prev = _context.next) {\n                case 0:\n                  prev = (_a = _this.key) === null || _a === void 0 ? void 0 : _a.getState(prevState);\n                  next = (_b = _this.key) === null || _b === void 0 ? void 0 : _b.getState(view.state); // See how the state changed\n                  moved = prev.active && next.active && prev.range.from !== next.range.from;\n                  started = !prev.active && next.active;\n                  stopped = prev.active && !next.active;\n                  changed = !started && !stopped && prev.query !== next.query;\n                  handleStart = started || moved;\n                  handleChange = changed && !moved;\n                  handleExit = stopped || moved; // Cancel when suggestion isn't active\n                  if (!(!handleStart && !handleChange && !handleExit)) {\n                    _context.next = 11;\n                    break;\n                  }\n                  return _context.abrupt(\"return\");\n                case 11:\n                  state = handleExit && !handleStart ? prev : next;\n                  decorationNode = view.dom.querySelector(\"[data-decoration-id=\\\"\".concat(state.decorationId, \"\\\"]\"));\n                  props = {\n                    editor: editor,\n                    range: state.range,\n                    query: state.query,\n                    text: state.text,\n                    items: [],\n                    command: function command(commandProps) {\n                      _command({\n                        editor: editor,\n                        range: state.range,\n                        props: commandProps\n                      });\n                    },\n                    decorationNode: decorationNode,\n                    // virtual node for popper.js or tippy.js\n                    // this can be used for building popups without a DOM node\n                    clientRect: decorationNode ? function () {\n                      var _a;\n                      // because of `items` can be asynchrounous we’ll search for the current decoration node\n                      var _ref2 = (_a = _this.key) === null || _a === void 0 ? void 0 : _a.getState(editor.state),\n                        decorationId = _ref2.decorationId; // eslint-disable-line\n                      var currentDecorationNode = view.dom.querySelector(\"[data-decoration-id=\\\"\".concat(decorationId, \"\\\"]\"));\n                      return (currentDecorationNode === null || currentDecorationNode === void 0 ? void 0 : currentDecorationNode.getBoundingClientRect()) || null;\n                    } : null\n                  };\n                  if (handleStart) {\n                    (_c = renderer === null || renderer === void 0 ? void 0 : renderer.onBeforeStart) === null || _c === void 0 ? void 0 : _c.call(renderer, props);\n                  }\n                  if (handleChange) {\n                    (_d = renderer === null || renderer === void 0 ? void 0 : renderer.onBeforeUpdate) === null || _d === void 0 ? void 0 : _d.call(renderer, props);\n                  }\n                  if (!(handleChange || handleStart)) {\n                    _context.next = 20;\n                    break;\n                  }\n                  _context.next = 19;\n                  return items({\n                    editor: editor,\n                    query: state.query\n                  });\n                case 19:\n                  props.items = _context.sent;\n                case 20:\n                  if (handleExit) {\n                    (_e = renderer === null || renderer === void 0 ? void 0 : renderer.onExit) === null || _e === void 0 ? void 0 : _e.call(renderer, props);\n                  }\n                  if (handleChange) {\n                    (_f = renderer === null || renderer === void 0 ? void 0 : renderer.onUpdate) === null || _f === void 0 ? void 0 : _f.call(renderer, props);\n                  }\n                  if (handleStart) {\n                    (_g = renderer === null || renderer === void 0 ? void 0 : renderer.onStart) === null || _g === void 0 ? void 0 : _g.call(renderer, props);\n                  }\n                case 23:\n                case \"end\":\n                  return _context.stop();\n              }\n            }, _callee);\n          }));\n          function update(_x, _x2) {\n            return _update.apply(this, arguments);\n          }\n          return update;\n        }(),\n        destroy: function destroy() {\n          var _a;\n          if (!props) {\n            return;\n          }\n          (_a = renderer === null || renderer === void 0 ? void 0 : renderer.onExit) === null || _a === void 0 ? void 0 : _a.call(renderer, props);\n        }\n      };\n    },\n    state: {\n      // Initialize the plugin's internal state.\n      init: function init() {\n        var state = {\n          active: false,\n          range: {\n            from: 0,\n            to: 0\n          },\n          query: null,\n          text: null,\n          composing: false\n        };\n        return state;\n      },\n      // Apply changes to the plugin state from a view transaction.\n      apply: function apply(transaction, prev, oldState, state) {\n        var isEditable = editor.isEditable;\n        var composing = editor.view.composing;\n        var selection = transaction.selection;\n        var empty = selection.empty,\n          from = selection.from;\n        var next = _objectSpread({}, prev);\n        next.composing = composing;\n        // We can only be suggesting if the view is editable, and:\n        //   * there is no selection, or\n        //   * a composition is active (see: https://github.com/ueberdosis/tiptap/issues/1449)\n        if (isEditable && (empty || editor.view.composing)) {\n          // Reset active state if we just left the previous suggestion range\n          if ((from < prev.range.from || from > prev.range.to) && !composing && !prev.composing) {\n            next.active = false;\n          }\n          // Try to match against where our cursor currently is\n          var match = findSuggestionMatch({\n            char: char,\n            allowSpaces: allowSpaces,\n            allowedPrefixes: allowedPrefixes,\n            startOfLine: startOfLine,\n            $position: selection.$from\n          });\n          var decorationId = \"id_\".concat(Math.floor(Math.random() * 0xFFFFFFFF));\n          // If we found a match, update the current state to show it\n          if (match && allow({\n            editor: editor,\n            state: state,\n            range: match.range\n          })) {\n            next.active = true;\n            next.decorationId = prev.decorationId ? prev.decorationId : decorationId;\n            next.range = match.range;\n            next.query = match.query;\n            next.text = match.text;\n          } else {\n            next.active = false;\n          }\n        } else {\n          next.active = false;\n        }\n        // Make sure to empty the range if suggestion is inactive\n        if (!next.active) {\n          next.decorationId = null;\n          next.range = {\n            from: 0,\n            to: 0\n          };\n          next.query = null;\n          next.text = null;\n        }\n        return next;\n      }\n    },\n    props: {\n      // Call the keydown hook if suggestion is active.\n      handleKeyDown: function handleKeyDown(view, event) {\n        var _a;\n        var _plugin$getState = plugin.getState(view.state),\n          active = _plugin$getState.active,\n          range = _plugin$getState.range;\n        if (!active) {\n          return false;\n        }\n        return ((_a = renderer === null || renderer === void 0 ? void 0 : renderer.onKeyDown) === null || _a === void 0 ? void 0 : _a.call(renderer, {\n          view: view,\n          event: event,\n          range: range\n        })) || false;\n      },\n      // Setup decorator on the currently active suggestion.\n      decorations: function decorations(state) {\n        var _plugin$getState2 = plugin.getState(state),\n          active = _plugin$getState2.active,\n          range = _plugin$getState2.range,\n          decorationId = _plugin$getState2.decorationId;\n        if (!active) {\n          return null;\n        }\n        return DecorationSet.create(state.doc, [Decoration.inline(range.from, range.to, {\n          nodeName: decorationTag,\n          class: decorationClass,\n          'data-decoration-id': decorationId\n        })]);\n      }\n    }\n  });\n  return plugin;\n}\nexport { Suggestion, SuggestionPluginKey, Suggestion as default, findSuggestionMatch };","map":{"version":3,"sources":["../src/findSuggestionMatch.ts","../src/suggestion.ts"],"names":[],"mappings":"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","sourcesContent":["import { escapeForRegEx, Range } from '@tiptap/core'\nimport { ResolvedPos } from 'prosemirror-model'\n\nexport interface Trigger {\n  char: string,\n  allowSpaces: boolean,\n  allowedPrefixes: string[] | null,\n  startOfLine: boolean,\n  $position: ResolvedPos,\n}\n\nexport type SuggestionMatch = {\n  range: Range,\n  query: string,\n  text: string,\n} | null\n\nexport function findSuggestionMatch(config: Trigger): SuggestionMatch {\n  const {\n    char,\n    allowSpaces,\n    allowedPrefixes,\n    startOfLine,\n    $position,\n  } = config\n\n  const escapedChar = escapeForRegEx(char)\n  const suffix = new RegExp(`\\\\s${escapedChar}$`)\n  const prefix = startOfLine ? '^' : ''\n  const regexp = allowSpaces\n    ? new RegExp(`${prefix}${escapedChar}.*?(?=\\\\s${escapedChar}|$)`, 'gm')\n    : new RegExp(`${prefix}(?:^)?${escapedChar}[^\\\\s${escapedChar}]*`, 'gm')\n\n  const text = $position.nodeBefore?.isText && $position.nodeBefore.text\n\n  if (!text) {\n    return null\n  }\n\n  const textFrom = $position.pos - text.length\n  const match = Array.from(text.matchAll(regexp)).pop()\n\n  if (!match || match.input === undefined || match.index === undefined) {\n    return null\n  }\n\n  // JavaScript doesn't have lookbehinds. This hacks a check that first character\n  // is a space or the start of the line\n  const matchPrefix = match.input.slice(Math.max(0, match.index - 1), match.index)\n  const matchPrefixIsAllowed = new RegExp(`^[${allowedPrefixes?.join('')}\\0]?$`).test(matchPrefix)\n\n  if (allowedPrefixes !== null && !matchPrefixIsAllowed) {\n    return null\n  }\n\n  // The absolute position of the match in the document\n  const from = textFrom + match.index\n  let to = from + match[0].length\n\n  // Edge case handling; if spaces are allowed and we're directly in between\n  // two triggers\n  if (allowSpaces && suffix.test(text.slice(to - 1, to + 1))) {\n    match[0] += ' '\n    to += 1\n  }\n\n  // If the $position is located within the matched substring, return that range\n  if (from < $position.pos && to >= $position.pos) {\n    return {\n      range: {\n        from,\n        to,\n      },\n      query: match[0].slice(char.length),\n      text: match[0],\n    }\n  }\n\n  return null\n}\n","import { Editor, Range } from '@tiptap/core'\nimport { EditorState, Plugin, PluginKey } from 'prosemirror-state'\nimport { Decoration, DecorationSet, EditorView } from 'prosemirror-view'\n\nimport { findSuggestionMatch } from './findSuggestionMatch'\n\nexport interface SuggestionOptions<I = any> {\n  pluginKey?: PluginKey,\n  editor: Editor,\n  char?: string,\n  allowSpaces?: boolean,\n  allowedPrefixes?: string[] | null,\n  startOfLine?: boolean,\n  decorationTag?: string,\n  decorationClass?: string,\n  command?: (props: {\n    editor: Editor,\n    range: Range,\n    props: I,\n  }) => void,\n  items?: (props: {\n    query: string,\n    editor: Editor,\n  }) => I[] | Promise<I[]>,\n  render?: () => {\n    onBeforeStart?: (props: SuggestionProps<I>) => void\n    onStart?: (props: SuggestionProps<I>) => void,\n    onBeforeUpdate?: (props: SuggestionProps<I>) => void\n    onUpdate?: (props: SuggestionProps<I>) => void,\n    onExit?: (props: SuggestionProps<I>) => void,\n    onKeyDown?: (props: SuggestionKeyDownProps) => boolean,\n  },\n  allow?: (props: {\n    editor: Editor,\n    state: EditorState,\n    range: Range,\n  }) => boolean,\n}\n\nexport interface SuggestionProps<I = any> {\n  editor: Editor,\n  range: Range,\n  query: string,\n  text: string,\n  items: I[],\n  command: (props: I) => void,\n  decorationNode: Element | null,\n  clientRect?: (() => DOMRect | null) | null,\n}\n\nexport interface SuggestionKeyDownProps {\n  view: EditorView,\n  event: KeyboardEvent,\n  range: Range,\n}\n\nexport const SuggestionPluginKey = new PluginKey('suggestion')\n\nexport function Suggestion<I = any>({\n  pluginKey = SuggestionPluginKey,\n  editor,\n  char = '@',\n  allowSpaces = false,\n  allowedPrefixes = [' '],\n  startOfLine = false,\n  decorationTag = 'span',\n  decorationClass = 'suggestion',\n  command = () => null,\n  items = () => [],\n  render = () => ({}),\n  allow = () => true,\n}: SuggestionOptions<I>) {\n\n  let props: SuggestionProps<I> | undefined\n  const renderer = render?.()\n\n  const plugin: Plugin<any> = new Plugin({\n    key: pluginKey,\n\n    view() {\n      return {\n        update: async (view, prevState) => {\n          const prev = this.key?.getState(prevState)\n          const next = this.key?.getState(view.state)\n\n          // See how the state changed\n          const moved = prev.active && next.active && prev.range.from !== next.range.from\n          const started = !prev.active && next.active\n          const stopped = prev.active && !next.active\n          const changed = !started && !stopped && prev.query !== next.query\n          const handleStart = started || moved\n          const handleChange = changed && !moved\n          const handleExit = stopped || moved\n\n          // Cancel when suggestion isn't active\n          if (!handleStart && !handleChange && !handleExit) {\n            return\n          }\n\n          const state = handleExit && !handleStart\n            ? prev\n            : next\n          const decorationNode = view.dom.querySelector(`[data-decoration-id=\"${state.decorationId}\"]`)\n\n          props = {\n            editor,\n            range: state.range,\n            query: state.query,\n            text: state.text,\n            items: [],\n            command: commandProps => {\n              command({\n                editor,\n                range: state.range,\n                props: commandProps,\n              })\n            },\n            decorationNode,\n            // virtual node for popper.js or tippy.js\n            // this can be used for building popups without a DOM node\n            clientRect: decorationNode\n              ? () => {\n                // because of `items` can be asynchrounous we’ll search for the current decoration node\n                const { decorationId } = this.key?.getState(editor.state) // eslint-disable-line\n                const currentDecorationNode = view.dom.querySelector(`[data-decoration-id=\"${decorationId}\"]`)\n\n                return currentDecorationNode?.getBoundingClientRect() || null\n              }\n              : null,\n          }\n\n          if (handleStart) {\n            renderer?.onBeforeStart?.(props)\n          }\n\n          if (handleChange) {\n            renderer?.onBeforeUpdate?.(props)\n          }\n\n          if (handleChange || handleStart) {\n            props.items = await items({\n              editor,\n              query: state.query,\n            })\n          }\n\n          if (handleExit) {\n            renderer?.onExit?.(props)\n          }\n\n          if (handleChange) {\n            renderer?.onUpdate?.(props)\n          }\n\n          if (handleStart) {\n            renderer?.onStart?.(props)\n          }\n        },\n\n        destroy: () => {\n          if (!props) {\n            return\n          }\n\n          renderer?.onExit?.(props)\n        },\n      }\n    },\n\n    state: {\n      // Initialize the plugin's internal state.\n      init() {\n        const state: {\n          active: boolean,\n          range: Range,\n          query: null | string\n          text: null | string\n          composing: boolean\n          decorationId?: string | null\n        } = {\n          active: false,\n          range: {\n            from: 0,\n            to: 0,\n          },\n          query: null,\n          text: null,\n          composing: false,\n        }\n\n        return state\n      },\n\n      // Apply changes to the plugin state from a view transaction.\n      apply(transaction, prev, oldState, state) {\n        const { isEditable } = editor\n        const { composing } = editor.view\n        const { selection } = transaction\n        const { empty, from } = selection\n        const next = { ...prev }\n\n        next.composing = composing\n\n        // We can only be suggesting if the view is editable, and:\n        //   * there is no selection, or\n        //   * a composition is active (see: https://github.com/ueberdosis/tiptap/issues/1449)\n        if (isEditable && (empty || editor.view.composing)) {\n          // Reset active state if we just left the previous suggestion range\n          if (\n            ((from < prev.range.from) || from > prev.range.to)\n            && !composing\n            && !prev.composing\n          ) {\n            next.active = false\n          }\n\n          // Try to match against where our cursor currently is\n          const match = findSuggestionMatch({\n            char,\n            allowSpaces,\n            allowedPrefixes,\n            startOfLine,\n            $position: selection.$from,\n          })\n          const decorationId = `id_${Math.floor(Math.random() * 0xFFFFFFFF)}`\n\n          // If we found a match, update the current state to show it\n          if (match && allow({ editor, state, range: match.range })) {\n            next.active = true\n            next.decorationId = prev.decorationId ? prev.decorationId : decorationId\n            next.range = match.range\n            next.query = match.query\n            next.text = match.text\n          } else {\n            next.active = false\n          }\n        } else {\n          next.active = false\n        }\n\n        // Make sure to empty the range if suggestion is inactive\n        if (!next.active) {\n          next.decorationId = null\n          next.range = { from: 0, to: 0 }\n          next.query = null\n          next.text = null\n        }\n\n        return next\n      },\n    },\n\n    props: {\n      // Call the keydown hook if suggestion is active.\n      handleKeyDown(view, event) {\n        const { active, range } = plugin.getState(view.state)\n\n        if (!active) {\n          return false\n        }\n\n        return renderer?.onKeyDown?.({ view, event, range }) || false\n      },\n\n      // Setup decorator on the currently active suggestion.\n      decorations(state) {\n        const { active, range, decorationId } = plugin.getState(state)\n\n        if (!active) {\n          return null\n        }\n\n        return DecorationSet.create(state.doc, [\n          Decoration.inline(range.from, range.to, {\n            nodeName: decorationTag,\n            class: decorationClass,\n            'data-decoration-id': decorationId,\n          }),\n        ])\n      },\n    },\n  })\n\n  return plugin\n}\n"]},"metadata":{},"sourceType":"module"}