{"ast":null,"code":"import { Extension } from '@tiptap/core';\nimport { Plugin } from 'prosemirror-state';\nimport { Decoration, DecorationSet } from 'prosemirror-view';\nvar Placeholder = Extension.create({\n  name: 'placeholder',\n  addOptions: function addOptions() {\n    return {\n      emptyEditorClass: 'is-editor-empty',\n      emptyNodeClass: 'is-empty',\n      placeholder: 'Write something …',\n      showOnlyWhenEditable: true,\n      showOnlyCurrent: true,\n      includeChildren: false\n    };\n  },\n  addProseMirrorPlugins: function addProseMirrorPlugins() {\n    var _this = this;\n    return [new Plugin({\n      props: {\n        decorations: function decorations(_ref) {\n          var doc = _ref.doc,\n            selection = _ref.selection;\n          var active = _this.editor.isEditable || !_this.options.showOnlyWhenEditable;\n          var anchor = selection.anchor;\n          var decorations = [];\n          if (!active) {\n            return null;\n          }\n          // only calculate isEmpty once due to its performance impacts (see issue #3360)\n          var emptyDocInstance = doc.type.createAndFill();\n          var isEditorEmpty = (emptyDocInstance === null || emptyDocInstance === void 0 ? void 0 : emptyDocInstance.sameMarkup(doc)) && emptyDocInstance.content.findDiffStart(doc.content) === null;\n          doc.descendants(function (node, pos) {\n            var hasAnchor = anchor >= pos && anchor <= pos + node.nodeSize;\n            var isEmpty = !node.isLeaf && !node.childCount;\n            if ((hasAnchor || !_this.options.showOnlyCurrent) && isEmpty) {\n              var classes = [_this.options.emptyNodeClass];\n              if (isEditorEmpty) {\n                classes.push(_this.options.emptyEditorClass);\n              }\n              var decoration = Decoration.node(pos, pos + node.nodeSize, {\n                class: classes.join(' '),\n                'data-placeholder': typeof _this.options.placeholder === 'function' ? _this.options.placeholder({\n                  editor: _this.editor,\n                  node: node,\n                  pos: pos,\n                  hasAnchor: hasAnchor\n                }) : _this.options.placeholder\n              });\n              decorations.push(decoration);\n            }\n            return _this.options.includeChildren;\n          });\n          return DecorationSet.create(doc, decorations);\n        }\n      }\n    })];\n  }\n});\nexport { Placeholder, Placeholder as default };","map":{"version":3,"sources":["../src/placeholder.ts"],"names":[],"mappings":";;;AAmBa,IAAA,WAAW,GAAG,SAAS,CAAC,MAAM,CAAqB;EAC9D,IAAI,EAAE,aAAa;EAEnB,UAAU,wBAAA;IACR,OAAO;MACL,gBAAgB,EAAE,iBAAiB;MACnC,cAAc,EAAE,UAAU;MAC1B,WAAW,EAAE,mBAAmB;MAChC,oBAAoB,EAAE,IAAI;MAC1B,eAAe,EAAE,IAAI;MACrB,eAAe,EAAE;KAClB;GACF;EAED,qBAAqB,mCAAA;IAAA;IACnB,OAAO,CACL,IAAI,MAAM,CAAC;MACT,KAAK,EAAE;QACL,WAAW,EAAE,2BAAuB;UAAA,IAApB,GAAG,QAAH,GAAG;YAAE,SAAS,QAAT,SAAS;UAC5B,IAAM,MAAM,GAAG,KAAI,CAAC,MAAM,CAAC,UAAU,IAAI,CAAC,KAAI,CAAC,OAAO,CAAC,oBAAoB;UAC3E,IAAQ,MAAM,GAAK,SAAS,CAApB,MAAM;UACd,IAAM,WAAW,GAAiB,EAAE;UAEpC,IAAI,CAAC,MAAM,EAAE;YACX,OAAO,IAAI;UACZ;;UAGD,IAAM,gBAAgB,GAAG,GAAG,CAAC,IAAI,CAAC,aAAa,EAAE;UACjD,IAAM,aAAa,GAAG,CAAA,gBAAgB,KAAA,IAAA,IAAhB,gBAAgB,KAAA,KAAA,CAAA,GAAA,KAAA,CAAA,GAAhB,gBAAgB,CAAE,UAAU,CAAC,GAAG,CAAC,KAAI,gBAAgB,CAAC,OAAO,CAAC,aAAa,CAAC,GAAG,CAAC,OAAO,CAAC,KAAK,IAAI;UAEvH,GAAG,CAAC,WAAW,CAAC,UAAC,IAAI,EAAE,GAAG,EAAI;YAC5B,IAAM,SAAS,GAAG,MAAM,IAAI,GAAG,IAAI,MAAM,IAAK,GAAG,GAAG,IAAI,CAAC,QAAS;YAClE,IAAM,OAAO,GAAG,CAAC,IAAI,CAAC,MAAM,IAAI,CAAC,IAAI,CAAC,UAAU;YAEhD,IAAI,CAAC,SAAS,IAAI,CAAC,KAAI,CAAC,OAAO,CAAC,eAAe,KAAK,OAAO,EAAE;cAC3D,IAAM,OAAO,GAAG,CAAC,KAAI,CAAC,OAAO,CAAC,cAAc,CAAC;cAE7C,IAAI,aAAa,EAAE;gBACjB,OAAO,CAAC,IAAI,CAAC,KAAI,CAAC,OAAO,CAAC,gBAAgB,CAAC;cAC5C;cAED,IAAM,UAAU,GAAG,UAAU,CAAC,IAAI,CAAC,GAAG,EAAE,GAAG,GAAG,IAAI,CAAC,QAAQ,EAAE;gBAC3D,KAAK,EAAE,OAAO,CAAC,IAAI,CAAC,GAAG,CAAC;gBACxB,kBAAkB,EAAE,OAAO,KAAI,CAAC,OAAO,CAAC,WAAW,KAAK,UAAU,GAC9D,KAAI,CAAC,OAAO,CAAC,WAAW,CAAC;kBACzB,MAAM,EAAE,KAAI,CAAC,MAAM;kBACnB,IAAI,EAAJ,IAAI;kBACJ,GAAG,EAAH,GAAG;kBACH,SAAS,EAAT;iBACD,CAAC,GACA,KAAI,CAAC,OAAO,CAAC;cAClB,CAAA,CAAC;cAEF,WAAW,CAAC,IAAI,CAAC,UAAU,CAAC;YAC7B;YAED,OAAO,KAAI,CAAC,OAAO,CAAC,eAAe;UACrC,CAAC,CAAC;UAEF,OAAO,aAAa,CAAC,MAAM,CAAC,GAAG,EAAE,WAAW,CAAC;QAC9C;MACF;KACF,CAAC,CACH;EACF;AACF,CAAA,CAAA","sourcesContent":["import { Editor, Extension } from '@tiptap/core'\nimport { Node as ProsemirrorNode } from 'prosemirror-model'\nimport { Plugin } from 'prosemirror-state'\nimport { Decoration, DecorationSet } from 'prosemirror-view'\n\nexport interface PlaceholderOptions {\n  emptyEditorClass: string,\n  emptyNodeClass: string,\n  placeholder: ((PlaceholderProps: {\n    editor: Editor,\n    node: ProsemirrorNode,\n    pos: number,\n    hasAnchor: boolean,\n  }) => string) | string,\n  showOnlyWhenEditable: boolean,\n  showOnlyCurrent: boolean,\n  includeChildren: boolean,\n}\n\nexport const Placeholder = Extension.create<PlaceholderOptions>({\n  name: 'placeholder',\n\n  addOptions() {\n    return {\n      emptyEditorClass: 'is-editor-empty',\n      emptyNodeClass: 'is-empty',\n      placeholder: 'Write something …',\n      showOnlyWhenEditable: true,\n      showOnlyCurrent: true,\n      includeChildren: false,\n    }\n  },\n\n  addProseMirrorPlugins() {\n    return [\n      new Plugin({\n        props: {\n          decorations: ({ doc, selection }) => {\n            const active = this.editor.isEditable || !this.options.showOnlyWhenEditable\n            const { anchor } = selection\n            const decorations: Decoration[] = []\n\n            if (!active) {\n              return null\n            }\n\n            // only calculate isEmpty once due to its performance impacts (see issue #3360)\n            const emptyDocInstance = doc.type.createAndFill()\n            const isEditorEmpty = emptyDocInstance?.sameMarkup(doc) && emptyDocInstance.content.findDiffStart(doc.content) === null\n\n            doc.descendants((node, pos) => {\n              const hasAnchor = anchor >= pos && anchor <= (pos + node.nodeSize)\n              const isEmpty = !node.isLeaf && !node.childCount\n\n              if ((hasAnchor || !this.options.showOnlyCurrent) && isEmpty) {\n                const classes = [this.options.emptyNodeClass]\n\n                if (isEditorEmpty) {\n                  classes.push(this.options.emptyEditorClass)\n                }\n\n                const decoration = Decoration.node(pos, pos + node.nodeSize, {\n                  class: classes.join(' '),\n                  'data-placeholder': typeof this.options.placeholder === 'function'\n                    ? this.options.placeholder({\n                      editor: this.editor,\n                      node,\n                      pos,\n                      hasAnchor,\n                    })\n                    : this.options.placeholder,\n                })\n\n                decorations.push(decoration)\n              }\n\n              return this.options.includeChildren\n            })\n\n            return DecorationSet.create(doc, decorations)\n          },\n        },\n      }),\n    ]\n  },\n})\n"]},"metadata":{},"sourceType":"module"}