{"ast":null,"code":"var _Parser = require('./lib/SparqlParser').Parser;\nvar Generator = require('./lib/SparqlGenerator');\nvar Wildcard = require(\"./lib/Wildcard\").Wildcard;\nvar _require = require('rdf-data-factory'),\n  DataFactory = _require.DataFactory;\nmodule.exports = {\n  /**\n   * Creates a SPARQL parser with the given pre-defined prefixes and base IRI\n   * @param options {\n   *   prefixes?: { [prefix: string]: string },\n   *   baseIRI?: string,\n   *   factory?: import('rdf-js').DataFactory,\n   *   sparqlStar?: boolean,\n   *   skipValidation?: boolean,\n   *   skipUngroupedVariableCheck?: boolean\n   * }\n   */\n  Parser: function Parser() {\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      prefixes = _ref.prefixes,\n      baseIRI = _ref.baseIRI,\n      factory = _ref.factory,\n      sparqlStar = _ref.sparqlStar,\n      skipValidation = _ref.skipValidation,\n      skipUngroupedVariableCheck = _ref.skipUngroupedVariableCheck,\n      pathOnly = _ref.pathOnly;\n    // Create a copy of the prefixes\n    var prefixesCopy = {};\n    for (var prefix in prefixes || {}) prefixesCopy[prefix] = prefixes[prefix];\n\n    // Create a new parser with the given prefixes\n    // (Workaround for https://github.com/zaach/jison/issues/241)\n    var parser = new _Parser();\n    parser.parse = function () {\n      _Parser.base = baseIRI || '';\n      _Parser.prefixes = Object.create(prefixesCopy);\n      _Parser.factory = factory || new DataFactory();\n      _Parser.sparqlStar = Boolean(sparqlStar);\n      _Parser.pathOnly = Boolean(pathOnly);\n      // We keep skipUngroupedVariableCheck for compatibility reasons.\n      _Parser.skipValidation = Boolean(skipValidation) || Boolean(skipUngroupedVariableCheck);\n      return _Parser.prototype.parse.apply(parser, arguments);\n    };\n    parser._resetBlanks = _Parser._resetBlanks;\n    return parser;\n  },\n  Generator: Generator,\n  Wildcard: Wildcard\n};","map":{"version":3,"names":["Parser","require","Generator","Wildcard","DataFactory","module","exports","prefixes","baseIRI","factory","sparqlStar","skipValidation","skipUngroupedVariableCheck","pathOnly","prefixesCopy","prefix","parser","parse","base","Object","create","Boolean","prototype","apply","arguments","_resetBlanks"],"sources":["/home/jean-daniel/Documents/Projets/DÃ©veloppement/ActivityPods/BCM/frontend/node_modules/sparqljs/sparql.js"],"sourcesContent":["var Parser = require('./lib/SparqlParser').Parser;\nvar Generator = require('./lib/SparqlGenerator');\nvar Wildcard = require(\"./lib/Wildcard\").Wildcard;\nvar { DataFactory } = require('rdf-data-factory');\n\nmodule.exports = {\n  /**\n   * Creates a SPARQL parser with the given pre-defined prefixes and base IRI\n   * @param options {\n   *   prefixes?: { [prefix: string]: string },\n   *   baseIRI?: string,\n   *   factory?: import('rdf-js').DataFactory,\n   *   sparqlStar?: boolean,\n   *   skipValidation?: boolean,\n   *   skipUngroupedVariableCheck?: boolean\n   * }\n   */\n  Parser: function ({ prefixes, baseIRI, factory, sparqlStar, skipValidation, skipUngroupedVariableCheck, pathOnly } = {}) {\n\n    // Create a copy of the prefixes\n    var prefixesCopy = {};\n    for (var prefix in prefixes || {})\n      prefixesCopy[prefix] = prefixes[prefix];\n\n    // Create a new parser with the given prefixes\n    // (Workaround for https://github.com/zaach/jison/issues/241)\n    var parser = new Parser();\n    parser.parse = function () {\n      Parser.base = baseIRI || '';\n      Parser.prefixes = Object.create(prefixesCopy);\n      Parser.factory = factory || new DataFactory();\n      Parser.sparqlStar = Boolean(sparqlStar);\n      Parser.pathOnly = Boolean(pathOnly);\n      // We keep skipUngroupedVariableCheck for compatibility reasons.\n      Parser.skipValidation = Boolean(skipValidation) || Boolean(skipUngroupedVariableCheck)\n      return Parser.prototype.parse.apply(parser, arguments);\n    };\n    parser._resetBlanks = Parser._resetBlanks;\n    return parser;\n  },\n  Generator: Generator,\n  Wildcard: Wildcard,\n};\n"],"mappings":"AAAA,IAAIA,OAAM,GAAGC,OAAO,CAAC,oBAAoB,CAAC,CAACD,MAAM;AACjD,IAAIE,SAAS,GAAGD,OAAO,CAAC,uBAAuB,CAAC;AAChD,IAAIE,QAAQ,GAAGF,OAAO,CAAC,gBAAgB,CAAC,CAACE,QAAQ;AACjD,eAAsBF,OAAO,CAAC,kBAAkB,CAAC;EAA3CG,WAAW,YAAXA,WAAW;AAEjBC,MAAM,CAACC,OAAO,GAAG;EACf;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEN,MAAM,EAAE,kBAAiH;IAAA,+EAAJ,CAAC,CAAC;MAAnGO,QAAQ,QAARA,QAAQ;MAAEC,OAAO,QAAPA,OAAO;MAAEC,OAAO,QAAPA,OAAO;MAAEC,UAAU,QAAVA,UAAU;MAAEC,cAAc,QAAdA,cAAc;MAAEC,0BAA0B,QAA1BA,0BAA0B;MAAEC,QAAQ,QAARA,QAAQ;IAE9G;IACA,IAAIC,YAAY,GAAG,CAAC,CAAC;IACrB,KAAK,IAAIC,MAAM,IAAIR,QAAQ,IAAI,CAAC,CAAC,EAC/BO,YAAY,CAACC,MAAM,CAAC,GAAGR,QAAQ,CAACQ,MAAM,CAAC;;IAEzC;IACA;IACA,IAAIC,MAAM,GAAG,IAAIhB,OAAM,EAAE;IACzBgB,MAAM,CAACC,KAAK,GAAG,YAAY;MACzBjB,OAAM,CAACkB,IAAI,GAAGV,OAAO,IAAI,EAAE;MAC3BR,OAAM,CAACO,QAAQ,GAAGY,MAAM,CAACC,MAAM,CAACN,YAAY,CAAC;MAC7Cd,OAAM,CAACS,OAAO,GAAGA,OAAO,IAAI,IAAIL,WAAW,EAAE;MAC7CJ,OAAM,CAACU,UAAU,GAAGW,OAAO,CAACX,UAAU,CAAC;MACvCV,OAAM,CAACa,QAAQ,GAAGQ,OAAO,CAACR,QAAQ,CAAC;MACnC;MACAb,OAAM,CAACW,cAAc,GAAGU,OAAO,CAACV,cAAc,CAAC,IAAIU,OAAO,CAACT,0BAA0B,CAAC;MACtF,OAAOZ,OAAM,CAACsB,SAAS,CAACL,KAAK,CAACM,KAAK,CAACP,MAAM,EAAEQ,SAAS,CAAC;IACxD,CAAC;IACDR,MAAM,CAACS,YAAY,GAAGzB,OAAM,CAACyB,YAAY;IACzC,OAAOT,MAAM;EACf,CAAC;EACDd,SAAS,EAAEA,SAAS;EACpBC,QAAQ,EAAEA;AACZ,CAAC"},"metadata":{},"sourceType":"script"}