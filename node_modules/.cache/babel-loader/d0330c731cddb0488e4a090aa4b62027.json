{"ast":null,"code":"import _classCallCheck from \"/home/jean-daniel/Documents/Projets/D\\xE9veloppement/ActivityPods/BCM/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/jean-daniel/Documents/Projets/D\\xE9veloppement/ActivityPods/BCM/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport RopeSequence from 'rope-sequence';\nimport { Mapping } from 'prosemirror-transform';\nimport { PluginKey, Plugin } from 'prosemirror-state';\n\n// ProseMirror's history isn't simply a way to roll back to a previous\n// state, because ProseMirror supports applying changes without adding\n// them to the history (for example during collaboration).\n//\n// To this end, each 'Branch' (one for the undo history and one for\n// the redo history) keeps an array of 'Items', which can optionally\n// hold a step (an actual undoable change), and always hold a position\n// map (which is needed to move changes below them to apply to the\n// current document).\n//\n// An item that has both a step and a selection bookmark is the start\n// of an 'event' — a group of changes that will be undone or redone at\n// once. (It stores only the bookmark, since that way we don't have to\n// provide a document until the selection is actually applied, which\n// is useful when compressing.)\n// Used to schedule history compression\nvar max_empty_items = 500;\nvar Branch = /*#__PURE__*/function () {\n  function Branch(items, eventCount) {\n    _classCallCheck(this, Branch);\n    this.items = items;\n    this.eventCount = eventCount;\n  }\n  // Pop the latest event off the branch's history and apply it\n  // to a document transform.\n  _createClass(Branch, [{\n    key: \"popEvent\",\n    value: function popEvent(state, preserveItems) {\n      var _this = this;\n      if (this.eventCount == 0) return null;\n      var end = this.items.length;\n      for (;; end--) {\n        var next = this.items.get(end - 1);\n        if (next.selection) {\n          --end;\n          break;\n        }\n      }\n      var remap, mapFrom;\n      if (preserveItems) {\n        remap = this.remapping(end, this.items.length);\n        mapFrom = remap.maps.length;\n      }\n      var transform = state.tr;\n      var selection, remaining;\n      var addAfter = [],\n        addBefore = [];\n      this.items.forEach(function (item, i) {\n        if (!item.step) {\n          if (!remap) {\n            remap = _this.remapping(end, i + 1);\n            mapFrom = remap.maps.length;\n          }\n          mapFrom--;\n          addBefore.push(item);\n          return;\n        }\n        if (remap) {\n          addBefore.push(new Item(item.map));\n          var step = item.step.map(remap.slice(mapFrom)),\n            map;\n          if (step && transform.maybeStep(step).doc) {\n            map = transform.mapping.maps[transform.mapping.maps.length - 1];\n            addAfter.push(new Item(map, undefined, undefined, addAfter.length + addBefore.length));\n          }\n          mapFrom--;\n          if (map) remap.appendMap(map, mapFrom);\n        } else {\n          transform.maybeStep(item.step);\n        }\n        if (item.selection) {\n          selection = remap ? item.selection.map(remap.slice(mapFrom)) : item.selection;\n          remaining = new Branch(_this.items.slice(0, end).append(addBefore.reverse().concat(addAfter)), _this.eventCount - 1);\n          return false;\n        }\n      }, this.items.length, 0);\n      return {\n        remaining: remaining,\n        transform: transform,\n        selection: selection\n      };\n    }\n    // Create a new branch with the given transform added.\n  }, {\n    key: \"addTransform\",\n    value: function addTransform(transform, selection, histOptions, preserveItems) {\n      var newItems = [],\n        eventCount = this.eventCount;\n      var oldItems = this.items,\n        lastItem = !preserveItems && oldItems.length ? oldItems.get(oldItems.length - 1) : null;\n      for (var i = 0; i < transform.steps.length; i++) {\n        var step = transform.steps[i].invert(transform.docs[i]);\n        var item = new Item(transform.mapping.maps[i], step, selection),\n          merged = void 0;\n        if (merged = lastItem && lastItem.merge(item)) {\n          item = merged;\n          if (i) newItems.pop();else oldItems = oldItems.slice(0, oldItems.length - 1);\n        }\n        newItems.push(item);\n        if (selection) {\n          eventCount++;\n          selection = undefined;\n        }\n        if (!preserveItems) lastItem = item;\n      }\n      var overflow = eventCount - histOptions.depth;\n      if (overflow > DEPTH_OVERFLOW) {\n        oldItems = cutOffEvents(oldItems, overflow);\n        eventCount -= overflow;\n      }\n      return new Branch(oldItems.append(newItems), eventCount);\n    }\n  }, {\n    key: \"remapping\",\n    value: function remapping(from, to) {\n      var maps = new Mapping();\n      this.items.forEach(function (item, i) {\n        var mirrorPos = item.mirrorOffset != null && i - item.mirrorOffset >= from ? maps.maps.length - item.mirrorOffset : undefined;\n        maps.appendMap(item.map, mirrorPos);\n      }, from, to);\n      return maps;\n    }\n  }, {\n    key: \"addMaps\",\n    value: function addMaps(array) {\n      if (this.eventCount == 0) return this;\n      return new Branch(this.items.append(array.map(function (map) {\n        return new Item(map);\n      })), this.eventCount);\n    }\n    // When the collab module receives remote changes, the history has\n    // to know about those, so that it can adjust the steps that were\n    // rebased on top of the remote changes, and include the position\n    // maps for the remote changes in its array of items.\n  }, {\n    key: \"rebased\",\n    value: function rebased(rebasedTransform, rebasedCount) {\n      if (!this.eventCount) return this;\n      var rebasedItems = [],\n        start = Math.max(0, this.items.length - rebasedCount);\n      var mapping = rebasedTransform.mapping;\n      var newUntil = rebasedTransform.steps.length;\n      var eventCount = this.eventCount;\n      this.items.forEach(function (item) {\n        if (item.selection) eventCount--;\n      }, start);\n      var iRebased = rebasedCount;\n      this.items.forEach(function (item) {\n        var pos = mapping.getMirror(--iRebased);\n        if (pos == null) return;\n        newUntil = Math.min(newUntil, pos);\n        var map = mapping.maps[pos];\n        if (item.step) {\n          var step = rebasedTransform.steps[pos].invert(rebasedTransform.docs[pos]);\n          var selection = item.selection && item.selection.map(mapping.slice(iRebased + 1, pos));\n          if (selection) eventCount++;\n          rebasedItems.push(new Item(map, step, selection));\n        } else {\n          rebasedItems.push(new Item(map));\n        }\n      }, start);\n      var newMaps = [];\n      for (var i = rebasedCount; i < newUntil; i++) newMaps.push(new Item(mapping.maps[i]));\n      var items = this.items.slice(0, start).append(newMaps).append(rebasedItems);\n      var branch = new Branch(items, eventCount);\n      if (branch.emptyItemCount() > max_empty_items) branch = branch.compress(this.items.length - rebasedItems.length);\n      return branch;\n    }\n  }, {\n    key: \"emptyItemCount\",\n    value: function emptyItemCount() {\n      var count = 0;\n      this.items.forEach(function (item) {\n        if (!item.step) count++;\n      });\n      return count;\n    }\n    // Compressing a branch means rewriting it to push the air (map-only\n    // items) out. During collaboration, these naturally accumulate\n    // because each remote change adds one. The `upto` argument is used\n    // to ensure that only the items below a given level are compressed,\n    // because `rebased` relies on a clean, untouched set of items in\n    // order to associate old items with rebased steps.\n  }, {\n    key: \"compress\",\n    value: function compress() {\n      var upto = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.items.length;\n      var remap = this.remapping(0, upto),\n        mapFrom = remap.maps.length;\n      var items = [],\n        events = 0;\n      this.items.forEach(function (item, i) {\n        if (i >= upto) {\n          items.push(item);\n          if (item.selection) events++;\n        } else if (item.step) {\n          var step = item.step.map(remap.slice(mapFrom)),\n            map = step && step.getMap();\n          mapFrom--;\n          if (map) remap.appendMap(map, mapFrom);\n          if (step) {\n            var selection = item.selection && item.selection.map(remap.slice(mapFrom));\n            if (selection) events++;\n            var newItem = new Item(map.invert(), step, selection),\n              merged,\n              last = items.length - 1;\n            if (merged = items.length && items[last].merge(newItem)) items[last] = merged;else items.push(newItem);\n          }\n        } else if (item.map) {\n          mapFrom--;\n        }\n      }, this.items.length, 0);\n      return new Branch(RopeSequence.from(items.reverse()), events);\n    }\n  }]);\n  return Branch;\n}();\nBranch.empty = new Branch(RopeSequence.empty, 0);\nfunction cutOffEvents(items, n) {\n  var cutPoint;\n  items.forEach(function (item, i) {\n    if (item.selection && n-- == 0) {\n      cutPoint = i;\n      return false;\n    }\n  });\n  return items.slice(cutPoint);\n}\nvar Item = /*#__PURE__*/function () {\n  function Item(\n  // The (forward) step map for this item.\n  map,\n  // The inverted step\n  step,\n  // If this is non-null, this item is the start of a group, and\n  // this selection is the starting selection for the group (the one\n  // that was active before the first step was applied)\n  selection,\n  // If this item is the inverse of a previous mapping on the stack,\n  // this points at the inverse's offset\n  mirrorOffset) {\n    _classCallCheck(this, Item);\n    this.map = map;\n    this.step = step;\n    this.selection = selection;\n    this.mirrorOffset = mirrorOffset;\n  }\n  _createClass(Item, [{\n    key: \"merge\",\n    value: function merge(other) {\n      if (this.step && other.step && !other.selection) {\n        var step = other.step.merge(this.step);\n        if (step) return new Item(step.getMap().invert(), step, this.selection);\n      }\n    }\n  }]);\n  return Item;\n}(); // The value of the state field that tracks undo/redo history for that\n// state. Will be stored in the plugin state when the history plugin\n// is active.\nvar HistoryState = /*#__PURE__*/_createClass(function HistoryState(done, undone, prevRanges, prevTime) {\n  _classCallCheck(this, HistoryState);\n  this.done = done;\n  this.undone = undone;\n  this.prevRanges = prevRanges;\n  this.prevTime = prevTime;\n});\nvar DEPTH_OVERFLOW = 20;\n// Record a transformation in undo history.\nfunction applyTransaction(history, state, tr, options) {\n  var historyTr = tr.getMeta(historyKey),\n    rebased;\n  if (historyTr) return historyTr.historyState;\n  if (tr.getMeta(closeHistoryKey)) history = new HistoryState(history.done, history.undone, null, 0);\n  var appended = tr.getMeta(\"appendedTransaction\");\n  if (tr.steps.length == 0) {\n    return history;\n  } else if (appended && appended.getMeta(historyKey)) {\n    if (appended.getMeta(historyKey).redo) return new HistoryState(history.done.addTransform(tr, undefined, options, mustPreserveItems(state)), history.undone, rangesFor(tr.mapping.maps[tr.steps.length - 1]), history.prevTime);else return new HistoryState(history.done, history.undone.addTransform(tr, undefined, options, mustPreserveItems(state)), null, history.prevTime);\n  } else if (tr.getMeta(\"addToHistory\") !== false && !(appended && appended.getMeta(\"addToHistory\") === false)) {\n    // Group transforms that occur in quick succession into one event.\n    var newGroup = history.prevTime == 0 || !appended && (history.prevTime < (tr.time || 0) - options.newGroupDelay || !isAdjacentTo(tr, history.prevRanges));\n    var prevRanges = appended ? mapRanges(history.prevRanges, tr.mapping) : rangesFor(tr.mapping.maps[tr.steps.length - 1]);\n    return new HistoryState(history.done.addTransform(tr, newGroup ? state.selection.getBookmark() : undefined, options, mustPreserveItems(state)), Branch.empty, prevRanges, tr.time);\n  } else if (rebased = tr.getMeta(\"rebased\")) {\n    // Used by the collab module to tell the history that some of its\n    // content has been rebased.\n    return new HistoryState(history.done.rebased(tr, rebased), history.undone.rebased(tr, rebased), mapRanges(history.prevRanges, tr.mapping), history.prevTime);\n  } else {\n    return new HistoryState(history.done.addMaps(tr.mapping.maps), history.undone.addMaps(tr.mapping.maps), mapRanges(history.prevRanges, tr.mapping), history.prevTime);\n  }\n}\nfunction isAdjacentTo(transform, prevRanges) {\n  if (!prevRanges) return false;\n  if (!transform.docChanged) return true;\n  var adjacent = false;\n  transform.mapping.maps[0].forEach(function (start, end) {\n    for (var i = 0; i < prevRanges.length; i += 2) if (start <= prevRanges[i + 1] && end >= prevRanges[i]) adjacent = true;\n  });\n  return adjacent;\n}\nfunction rangesFor(map) {\n  var result = [];\n  map.forEach(function (_from, _to, from, to) {\n    return result.push(from, to);\n  });\n  return result;\n}\nfunction mapRanges(ranges, mapping) {\n  if (!ranges) return null;\n  var result = [];\n  for (var i = 0; i < ranges.length; i += 2) {\n    var from = mapping.map(ranges[i], 1),\n      to = mapping.map(ranges[i + 1], -1);\n    if (from <= to) result.push(from, to);\n  }\n  return result;\n}\n// Apply the latest event from one branch to the document and shift the event\n// onto the other branch.\nfunction histTransaction(history, state, dispatch, redo) {\n  var preserveItems = mustPreserveItems(state);\n  var histOptions = historyKey.get(state).spec.config;\n  var pop = (redo ? history.undone : history.done).popEvent(state, preserveItems);\n  if (!pop) return;\n  var selection = pop.selection.resolve(pop.transform.doc);\n  var added = (redo ? history.done : history.undone).addTransform(pop.transform, state.selection.getBookmark(), histOptions, preserveItems);\n  var newHist = new HistoryState(redo ? added : pop.remaining, redo ? pop.remaining : added, null, 0);\n  dispatch(pop.transform.setSelection(selection).setMeta(historyKey, {\n    redo: redo,\n    historyState: newHist\n  }).scrollIntoView());\n}\nvar cachedPreserveItems = false,\n  cachedPreserveItemsPlugins = null;\n// Check whether any plugin in the given state has a\n// `historyPreserveItems` property in its spec, in which case we must\n// preserve steps exactly as they came in, so that they can be\n// rebased.\nfunction mustPreserveItems(state) {\n  var plugins = state.plugins;\n  if (cachedPreserveItemsPlugins != plugins) {\n    cachedPreserveItems = false;\n    cachedPreserveItemsPlugins = plugins;\n    for (var i = 0; i < plugins.length; i++) if (plugins[i].spec.historyPreserveItems) {\n      cachedPreserveItems = true;\n      break;\n    }\n  }\n  return cachedPreserveItems;\n}\n/**\nSet a flag on the given transaction that will prevent further steps\nfrom being appended to an existing history event (so that they\nrequire a separate undo command to undo).\n*/\nfunction closeHistory(tr) {\n  return tr.setMeta(closeHistoryKey, true);\n}\nvar historyKey = new PluginKey(\"history\");\nvar closeHistoryKey = new PluginKey(\"closeHistory\");\n/**\nReturns a plugin that enables the undo history for an editor. The\nplugin will track undo and redo stacks, which can be used with the\n[`undo`](https://prosemirror.net/docs/ref/#history.undo) and [`redo`](https://prosemirror.net/docs/ref/#history.redo) commands.\n\nYou can set an `\"addToHistory\"` [metadata\nproperty](https://prosemirror.net/docs/ref/#state.Transaction.setMeta) of `false` on a transaction\nto prevent it from being rolled back by undo.\n*/\nfunction history() {\n  var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  config = {\n    depth: config.depth || 100,\n    newGroupDelay: config.newGroupDelay || 500\n  };\n  return new Plugin({\n    key: historyKey,\n    state: {\n      init: function init() {\n        return new HistoryState(Branch.empty, Branch.empty, null, 0);\n      },\n      apply: function apply(tr, hist, state) {\n        return applyTransaction(hist, state, tr, config);\n      }\n    },\n    config: config,\n    props: {\n      handleDOMEvents: {\n        beforeinput: function beforeinput(view, e) {\n          var inputType = e.inputType;\n          var command = inputType == \"historyUndo\" ? undo : inputType == \"historyRedo\" ? redo : null;\n          if (!command) return false;\n          e.preventDefault();\n          return command(view.state, view.dispatch);\n        }\n      }\n    }\n  });\n}\n/**\nA command function that undoes the last change, if any.\n*/\nvar undo = function undo(state, dispatch) {\n  var hist = historyKey.getState(state);\n  if (!hist || hist.done.eventCount == 0) return false;\n  if (dispatch) histTransaction(hist, state, dispatch, false);\n  return true;\n};\n/**\nA command function that redoes the last undone change, if any.\n*/\nvar redo = function redo(state, dispatch) {\n  var hist = historyKey.getState(state);\n  if (!hist || hist.undone.eventCount == 0) return false;\n  if (dispatch) histTransaction(hist, state, dispatch, true);\n  return true;\n};\n/**\nThe amount of undoable events available in a given state.\n*/\nfunction undoDepth(state) {\n  var hist = historyKey.getState(state);\n  return hist ? hist.done.eventCount : 0;\n}\n/**\nThe amount of redoable events available in a given editor state.\n*/\nfunction redoDepth(state) {\n  var hist = historyKey.getState(state);\n  return hist ? hist.undone.eventCount : 0;\n}\nexport { closeHistory, history, redo, redoDepth, undo, undoDepth };","map":{"version":3,"names":["RopeSequence","Mapping","PluginKey","Plugin","max_empty_items","Branch","items","eventCount","state","preserveItems","end","length","next","get","selection","remap","mapFrom","remapping","maps","transform","tr","remaining","addAfter","addBefore","forEach","item","i","step","push","Item","map","slice","maybeStep","doc","mapping","undefined","appendMap","append","reverse","concat","histOptions","newItems","oldItems","lastItem","steps","invert","docs","merged","merge","pop","overflow","depth","DEPTH_OVERFLOW","cutOffEvents","from","to","mirrorPos","mirrorOffset","array","rebasedTransform","rebasedCount","rebasedItems","start","Math","max","newUntil","iRebased","pos","getMirror","min","newMaps","branch","emptyItemCount","compress","count","upto","events","getMap","newItem","last","empty","n","cutPoint","other","HistoryState","done","undone","prevRanges","prevTime","applyTransaction","history","options","historyTr","getMeta","historyKey","rebased","historyState","closeHistoryKey","appended","redo","addTransform","mustPreserveItems","rangesFor","newGroup","time","newGroupDelay","isAdjacentTo","mapRanges","getBookmark","addMaps","docChanged","adjacent","result","_from","_to","ranges","histTransaction","dispatch","spec","config","popEvent","resolve","added","newHist","setSelection","setMeta","scrollIntoView","cachedPreserveItems","cachedPreserveItemsPlugins","plugins","historyPreserveItems","closeHistory","key","init","apply","hist","props","handleDOMEvents","beforeinput","view","e","inputType","command","undo","preventDefault","getState","undoDepth","redoDepth"],"sources":["/home/jean-daniel/Documents/Projets/Développement/ActivityPods/BCM/frontend/node_modules/prosemirror-history/dist/index.js"],"sourcesContent":["import RopeSequence from 'rope-sequence';\nimport { Mapping } from 'prosemirror-transform';\nimport { PluginKey, Plugin } from 'prosemirror-state';\n\n// ProseMirror's history isn't simply a way to roll back to a previous\n// state, because ProseMirror supports applying changes without adding\n// them to the history (for example during collaboration).\n//\n// To this end, each 'Branch' (one for the undo history and one for\n// the redo history) keeps an array of 'Items', which can optionally\n// hold a step (an actual undoable change), and always hold a position\n// map (which is needed to move changes below them to apply to the\n// current document).\n//\n// An item that has both a step and a selection bookmark is the start\n// of an 'event' — a group of changes that will be undone or redone at\n// once. (It stores only the bookmark, since that way we don't have to\n// provide a document until the selection is actually applied, which\n// is useful when compressing.)\n// Used to schedule history compression\nconst max_empty_items = 500;\nclass Branch {\n    constructor(items, eventCount) {\n        this.items = items;\n        this.eventCount = eventCount;\n    }\n    // Pop the latest event off the branch's history and apply it\n    // to a document transform.\n    popEvent(state, preserveItems) {\n        if (this.eventCount == 0)\n            return null;\n        let end = this.items.length;\n        for (;; end--) {\n            let next = this.items.get(end - 1);\n            if (next.selection) {\n                --end;\n                break;\n            }\n        }\n        let remap, mapFrom;\n        if (preserveItems) {\n            remap = this.remapping(end, this.items.length);\n            mapFrom = remap.maps.length;\n        }\n        let transform = state.tr;\n        let selection, remaining;\n        let addAfter = [], addBefore = [];\n        this.items.forEach((item, i) => {\n            if (!item.step) {\n                if (!remap) {\n                    remap = this.remapping(end, i + 1);\n                    mapFrom = remap.maps.length;\n                }\n                mapFrom--;\n                addBefore.push(item);\n                return;\n            }\n            if (remap) {\n                addBefore.push(new Item(item.map));\n                let step = item.step.map(remap.slice(mapFrom)), map;\n                if (step && transform.maybeStep(step).doc) {\n                    map = transform.mapping.maps[transform.mapping.maps.length - 1];\n                    addAfter.push(new Item(map, undefined, undefined, addAfter.length + addBefore.length));\n                }\n                mapFrom--;\n                if (map)\n                    remap.appendMap(map, mapFrom);\n            }\n            else {\n                transform.maybeStep(item.step);\n            }\n            if (item.selection) {\n                selection = remap ? item.selection.map(remap.slice(mapFrom)) : item.selection;\n                remaining = new Branch(this.items.slice(0, end).append(addBefore.reverse().concat(addAfter)), this.eventCount - 1);\n                return false;\n            }\n        }, this.items.length, 0);\n        return { remaining: remaining, transform, selection: selection };\n    }\n    // Create a new branch with the given transform added.\n    addTransform(transform, selection, histOptions, preserveItems) {\n        let newItems = [], eventCount = this.eventCount;\n        let oldItems = this.items, lastItem = !preserveItems && oldItems.length ? oldItems.get(oldItems.length - 1) : null;\n        for (let i = 0; i < transform.steps.length; i++) {\n            let step = transform.steps[i].invert(transform.docs[i]);\n            let item = new Item(transform.mapping.maps[i], step, selection), merged;\n            if (merged = lastItem && lastItem.merge(item)) {\n                item = merged;\n                if (i)\n                    newItems.pop();\n                else\n                    oldItems = oldItems.slice(0, oldItems.length - 1);\n            }\n            newItems.push(item);\n            if (selection) {\n                eventCount++;\n                selection = undefined;\n            }\n            if (!preserveItems)\n                lastItem = item;\n        }\n        let overflow = eventCount - histOptions.depth;\n        if (overflow > DEPTH_OVERFLOW) {\n            oldItems = cutOffEvents(oldItems, overflow);\n            eventCount -= overflow;\n        }\n        return new Branch(oldItems.append(newItems), eventCount);\n    }\n    remapping(from, to) {\n        let maps = new Mapping;\n        this.items.forEach((item, i) => {\n            let mirrorPos = item.mirrorOffset != null && i - item.mirrorOffset >= from\n                ? maps.maps.length - item.mirrorOffset : undefined;\n            maps.appendMap(item.map, mirrorPos);\n        }, from, to);\n        return maps;\n    }\n    addMaps(array) {\n        if (this.eventCount == 0)\n            return this;\n        return new Branch(this.items.append(array.map(map => new Item(map))), this.eventCount);\n    }\n    // When the collab module receives remote changes, the history has\n    // to know about those, so that it can adjust the steps that were\n    // rebased on top of the remote changes, and include the position\n    // maps for the remote changes in its array of items.\n    rebased(rebasedTransform, rebasedCount) {\n        if (!this.eventCount)\n            return this;\n        let rebasedItems = [], start = Math.max(0, this.items.length - rebasedCount);\n        let mapping = rebasedTransform.mapping;\n        let newUntil = rebasedTransform.steps.length;\n        let eventCount = this.eventCount;\n        this.items.forEach(item => { if (item.selection)\n            eventCount--; }, start);\n        let iRebased = rebasedCount;\n        this.items.forEach(item => {\n            let pos = mapping.getMirror(--iRebased);\n            if (pos == null)\n                return;\n            newUntil = Math.min(newUntil, pos);\n            let map = mapping.maps[pos];\n            if (item.step) {\n                let step = rebasedTransform.steps[pos].invert(rebasedTransform.docs[pos]);\n                let selection = item.selection && item.selection.map(mapping.slice(iRebased + 1, pos));\n                if (selection)\n                    eventCount++;\n                rebasedItems.push(new Item(map, step, selection));\n            }\n            else {\n                rebasedItems.push(new Item(map));\n            }\n        }, start);\n        let newMaps = [];\n        for (let i = rebasedCount; i < newUntil; i++)\n            newMaps.push(new Item(mapping.maps[i]));\n        let items = this.items.slice(0, start).append(newMaps).append(rebasedItems);\n        let branch = new Branch(items, eventCount);\n        if (branch.emptyItemCount() > max_empty_items)\n            branch = branch.compress(this.items.length - rebasedItems.length);\n        return branch;\n    }\n    emptyItemCount() {\n        let count = 0;\n        this.items.forEach(item => { if (!item.step)\n            count++; });\n        return count;\n    }\n    // Compressing a branch means rewriting it to push the air (map-only\n    // items) out. During collaboration, these naturally accumulate\n    // because each remote change adds one. The `upto` argument is used\n    // to ensure that only the items below a given level are compressed,\n    // because `rebased` relies on a clean, untouched set of items in\n    // order to associate old items with rebased steps.\n    compress(upto = this.items.length) {\n        let remap = this.remapping(0, upto), mapFrom = remap.maps.length;\n        let items = [], events = 0;\n        this.items.forEach((item, i) => {\n            if (i >= upto) {\n                items.push(item);\n                if (item.selection)\n                    events++;\n            }\n            else if (item.step) {\n                let step = item.step.map(remap.slice(mapFrom)), map = step && step.getMap();\n                mapFrom--;\n                if (map)\n                    remap.appendMap(map, mapFrom);\n                if (step) {\n                    let selection = item.selection && item.selection.map(remap.slice(mapFrom));\n                    if (selection)\n                        events++;\n                    let newItem = new Item(map.invert(), step, selection), merged, last = items.length - 1;\n                    if (merged = items.length && items[last].merge(newItem))\n                        items[last] = merged;\n                    else\n                        items.push(newItem);\n                }\n            }\n            else if (item.map) {\n                mapFrom--;\n            }\n        }, this.items.length, 0);\n        return new Branch(RopeSequence.from(items.reverse()), events);\n    }\n}\nBranch.empty = new Branch(RopeSequence.empty, 0);\nfunction cutOffEvents(items, n) {\n    let cutPoint;\n    items.forEach((item, i) => {\n        if (item.selection && (n-- == 0)) {\n            cutPoint = i;\n            return false;\n        }\n    });\n    return items.slice(cutPoint);\n}\nclass Item {\n    constructor(\n    // The (forward) step map for this item.\n    map, \n    // The inverted step\n    step, \n    // If this is non-null, this item is the start of a group, and\n    // this selection is the starting selection for the group (the one\n    // that was active before the first step was applied)\n    selection, \n    // If this item is the inverse of a previous mapping on the stack,\n    // this points at the inverse's offset\n    mirrorOffset) {\n        this.map = map;\n        this.step = step;\n        this.selection = selection;\n        this.mirrorOffset = mirrorOffset;\n    }\n    merge(other) {\n        if (this.step && other.step && !other.selection) {\n            let step = other.step.merge(this.step);\n            if (step)\n                return new Item(step.getMap().invert(), step, this.selection);\n        }\n    }\n}\n// The value of the state field that tracks undo/redo history for that\n// state. Will be stored in the plugin state when the history plugin\n// is active.\nclass HistoryState {\n    constructor(done, undone, prevRanges, prevTime) {\n        this.done = done;\n        this.undone = undone;\n        this.prevRanges = prevRanges;\n        this.prevTime = prevTime;\n    }\n}\nconst DEPTH_OVERFLOW = 20;\n// Record a transformation in undo history.\nfunction applyTransaction(history, state, tr, options) {\n    let historyTr = tr.getMeta(historyKey), rebased;\n    if (historyTr)\n        return historyTr.historyState;\n    if (tr.getMeta(closeHistoryKey))\n        history = new HistoryState(history.done, history.undone, null, 0);\n    let appended = tr.getMeta(\"appendedTransaction\");\n    if (tr.steps.length == 0) {\n        return history;\n    }\n    else if (appended && appended.getMeta(historyKey)) {\n        if (appended.getMeta(historyKey).redo)\n            return new HistoryState(history.done.addTransform(tr, undefined, options, mustPreserveItems(state)), history.undone, rangesFor(tr.mapping.maps[tr.steps.length - 1]), history.prevTime);\n        else\n            return new HistoryState(history.done, history.undone.addTransform(tr, undefined, options, mustPreserveItems(state)), null, history.prevTime);\n    }\n    else if (tr.getMeta(\"addToHistory\") !== false && !(appended && appended.getMeta(\"addToHistory\") === false)) {\n        // Group transforms that occur in quick succession into one event.\n        let newGroup = history.prevTime == 0 || !appended && (history.prevTime < (tr.time || 0) - options.newGroupDelay ||\n            !isAdjacentTo(tr, history.prevRanges));\n        let prevRanges = appended ? mapRanges(history.prevRanges, tr.mapping) : rangesFor(tr.mapping.maps[tr.steps.length - 1]);\n        return new HistoryState(history.done.addTransform(tr, newGroup ? state.selection.getBookmark() : undefined, options, mustPreserveItems(state)), Branch.empty, prevRanges, tr.time);\n    }\n    else if (rebased = tr.getMeta(\"rebased\")) {\n        // Used by the collab module to tell the history that some of its\n        // content has been rebased.\n        return new HistoryState(history.done.rebased(tr, rebased), history.undone.rebased(tr, rebased), mapRanges(history.prevRanges, tr.mapping), history.prevTime);\n    }\n    else {\n        return new HistoryState(history.done.addMaps(tr.mapping.maps), history.undone.addMaps(tr.mapping.maps), mapRanges(history.prevRanges, tr.mapping), history.prevTime);\n    }\n}\nfunction isAdjacentTo(transform, prevRanges) {\n    if (!prevRanges)\n        return false;\n    if (!transform.docChanged)\n        return true;\n    let adjacent = false;\n    transform.mapping.maps[0].forEach((start, end) => {\n        for (let i = 0; i < prevRanges.length; i += 2)\n            if (start <= prevRanges[i + 1] && end >= prevRanges[i])\n                adjacent = true;\n    });\n    return adjacent;\n}\nfunction rangesFor(map) {\n    let result = [];\n    map.forEach((_from, _to, from, to) => result.push(from, to));\n    return result;\n}\nfunction mapRanges(ranges, mapping) {\n    if (!ranges)\n        return null;\n    let result = [];\n    for (let i = 0; i < ranges.length; i += 2) {\n        let from = mapping.map(ranges[i], 1), to = mapping.map(ranges[i + 1], -1);\n        if (from <= to)\n            result.push(from, to);\n    }\n    return result;\n}\n// Apply the latest event from one branch to the document and shift the event\n// onto the other branch.\nfunction histTransaction(history, state, dispatch, redo) {\n    let preserveItems = mustPreserveItems(state);\n    let histOptions = historyKey.get(state).spec.config;\n    let pop = (redo ? history.undone : history.done).popEvent(state, preserveItems);\n    if (!pop)\n        return;\n    let selection = pop.selection.resolve(pop.transform.doc);\n    let added = (redo ? history.done : history.undone).addTransform(pop.transform, state.selection.getBookmark(), histOptions, preserveItems);\n    let newHist = new HistoryState(redo ? added : pop.remaining, redo ? pop.remaining : added, null, 0);\n    dispatch(pop.transform.setSelection(selection).setMeta(historyKey, { redo, historyState: newHist }).scrollIntoView());\n}\nlet cachedPreserveItems = false, cachedPreserveItemsPlugins = null;\n// Check whether any plugin in the given state has a\n// `historyPreserveItems` property in its spec, in which case we must\n// preserve steps exactly as they came in, so that they can be\n// rebased.\nfunction mustPreserveItems(state) {\n    let plugins = state.plugins;\n    if (cachedPreserveItemsPlugins != plugins) {\n        cachedPreserveItems = false;\n        cachedPreserveItemsPlugins = plugins;\n        for (let i = 0; i < plugins.length; i++)\n            if (plugins[i].spec.historyPreserveItems) {\n                cachedPreserveItems = true;\n                break;\n            }\n    }\n    return cachedPreserveItems;\n}\n/**\nSet a flag on the given transaction that will prevent further steps\nfrom being appended to an existing history event (so that they\nrequire a separate undo command to undo).\n*/\nfunction closeHistory(tr) {\n    return tr.setMeta(closeHistoryKey, true);\n}\nconst historyKey = new PluginKey(\"history\");\nconst closeHistoryKey = new PluginKey(\"closeHistory\");\n/**\nReturns a plugin that enables the undo history for an editor. The\nplugin will track undo and redo stacks, which can be used with the\n[`undo`](https://prosemirror.net/docs/ref/#history.undo) and [`redo`](https://prosemirror.net/docs/ref/#history.redo) commands.\n\nYou can set an `\"addToHistory\"` [metadata\nproperty](https://prosemirror.net/docs/ref/#state.Transaction.setMeta) of `false` on a transaction\nto prevent it from being rolled back by undo.\n*/\nfunction history(config = {}) {\n    config = { depth: config.depth || 100,\n        newGroupDelay: config.newGroupDelay || 500 };\n    return new Plugin({\n        key: historyKey,\n        state: {\n            init() {\n                return new HistoryState(Branch.empty, Branch.empty, null, 0);\n            },\n            apply(tr, hist, state) {\n                return applyTransaction(hist, state, tr, config);\n            }\n        },\n        config,\n        props: {\n            handleDOMEvents: {\n                beforeinput(view, e) {\n                    let inputType = e.inputType;\n                    let command = inputType == \"historyUndo\" ? undo : inputType == \"historyRedo\" ? redo : null;\n                    if (!command)\n                        return false;\n                    e.preventDefault();\n                    return command(view.state, view.dispatch);\n                }\n            }\n        }\n    });\n}\n/**\nA command function that undoes the last change, if any.\n*/\nconst undo = (state, dispatch) => {\n    let hist = historyKey.getState(state);\n    if (!hist || hist.done.eventCount == 0)\n        return false;\n    if (dispatch)\n        histTransaction(hist, state, dispatch, false);\n    return true;\n};\n/**\nA command function that redoes the last undone change, if any.\n*/\nconst redo = (state, dispatch) => {\n    let hist = historyKey.getState(state);\n    if (!hist || hist.undone.eventCount == 0)\n        return false;\n    if (dispatch)\n        histTransaction(hist, state, dispatch, true);\n    return true;\n};\n/**\nThe amount of undoable events available in a given state.\n*/\nfunction undoDepth(state) {\n    let hist = historyKey.getState(state);\n    return hist ? hist.done.eventCount : 0;\n}\n/**\nThe amount of redoable events available in a given editor state.\n*/\nfunction redoDepth(state) {\n    let hist = historyKey.getState(state);\n    return hist ? hist.undone.eventCount : 0;\n}\n\nexport { closeHistory, history, redo, redoDepth, undo, undoDepth };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}