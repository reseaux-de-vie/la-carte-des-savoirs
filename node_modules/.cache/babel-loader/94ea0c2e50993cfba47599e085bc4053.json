{"ast":null,"code":"/*\n * Copyright (c) 2019 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nvar _toConsumableArray = require(\"/home/jean-daniel/Documents/Projets/D\\xE9veloppement/ActivityPods/BCM/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\nvar _createForOfIteratorHelper = require(\"/home/jean-daniel/Documents/Projets/D\\xE9veloppement/ActivityPods/BCM/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\nvar _asyncToGenerator = require(\"/home/jean-daniel/Documents/Projets/D\\xE9veloppement/ActivityPods/BCM/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\nvar _classCallCheck = require(\"/home/jean-daniel/Documents/Projets/D\\xE9veloppement/ActivityPods/BCM/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\nvar _createClass = require(\"/home/jean-daniel/Documents/Projets/D\\xE9veloppement/ActivityPods/BCM/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = \"function\" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || \"@@iterator\", asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\", toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, \"\"); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, \"_invoke\", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: \"normal\", arg: fn.call(obj, arg) }; } catch (err) { return { type: \"throw\", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { [\"next\", \"throw\", \"return\"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if (\"throw\" !== record.type) { var result = record.arg, value = result.value; return value && \"object\" == typeof value && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke(\"next\", value, resolve, reject); }, function (err) { invoke(\"throw\", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke(\"throw\", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, \"_invoke\", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = \"suspendedStart\"; return function (method, arg) { if (\"executing\" === state) throw new Error(\"Generator is already running\"); if (\"completed\" === state) { if (\"throw\" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) { if (\"suspendedStart\" === state) throw state = \"completed\", context.arg; context.dispatchException(context.arg); } else \"return\" === context.method && context.abrupt(\"return\", context.arg); state = \"executing\"; var record = tryCatch(innerFn, self, context); if (\"normal\" === record.type) { if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, \"throw\" === methodName && delegate.iterator.return && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method) || \"return\" !== methodName && (context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a '\" + methodName + \"' method\")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = \"normal\", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: \"root\" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if (\"function\" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, \"constructor\", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, \"constructor\", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) { var ctor = \"function\" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, \"toString\", function () { return \"[object Generator]\"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if (\"throw\" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if (\"root\" === entry.tryLoc) return handle(\"end\"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, \"catchLoc\"), hasFinally = hasOwn.call(entry, \"finallyLoc\"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error(\"try statement without catch or finally\"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if (\"throw\" === record.type) throw record.arg; return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if (\"throw\" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\nvar _require = require('./types'),\n  _isArray = _require.isArray,\n  _isObject = _require.isObject,\n  _isString = _require.isString;\nvar _require2 = require('./util'),\n  _asArray = _require2.asArray;\nvar _require3 = require('./url'),\n  prependBase = _require3.prependBase;\nvar JsonLdError = require('./JsonLdError');\nvar ResolvedContext = require('./ResolvedContext');\nvar MAX_CONTEXT_URLS = 10;\nmodule.exports = /*#__PURE__*/function () {\n  /**\n   * Creates a ContextResolver.\n   *\n   * @param sharedCache a shared LRU cache with `get` and `set` APIs.\n   */\n  function ContextResolver(_ref) {\n    var sharedCache = _ref.sharedCache;\n    _classCallCheck(this, ContextResolver);\n    this.perOpCache = new Map();\n    this.sharedCache = sharedCache;\n  }\n  _createClass(ContextResolver, [{\n    key: \"resolve\",\n    value: function () {\n      var _resolve = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(_ref2) {\n        var activeCtx, context, documentLoader, base, _ref2$cycles, cycles, allResolved, _iterator, _step, ctx, _resolved, key, resolved;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              activeCtx = _ref2.activeCtx, context = _ref2.context, documentLoader = _ref2.documentLoader, base = _ref2.base, _ref2$cycles = _ref2.cycles, cycles = _ref2$cycles === void 0 ? new Set() : _ref2$cycles;\n              // process `@context`\n              if (context && _isObject(context) && context['@context']) {\n                context = context['@context'];\n              }\n\n              // context is one or more contexts\n              context = _asArray(context);\n\n              // resolve each context in the array\n              allResolved = [];\n              _iterator = _createForOfIteratorHelper(context);\n              _context.prev = 5;\n              _iterator.s();\n            case 7:\n              if ((_step = _iterator.n()).done) {\n                _context.next = 27;\n                break;\n              }\n              ctx = _step.value;\n              if (!_isString(ctx)) {\n                _context.next = 17;\n                break;\n              }\n              // see if `ctx` has been resolved before...\n              _resolved = this._get(ctx);\n              if (_resolved) {\n                _context.next = 15;\n                break;\n              }\n              _context.next = 14;\n              return this._resolveRemoteContext({\n                activeCtx: activeCtx,\n                url: ctx,\n                documentLoader: documentLoader,\n                base: base,\n                cycles: cycles\n              });\n            case 14:\n              _resolved = _context.sent;\n            case 15:\n              // add to output and continue\n              if (_isArray(_resolved)) {\n                allResolved.push.apply(allResolved, _toConsumableArray(_resolved));\n              } else {\n                allResolved.push(_resolved);\n              }\n              return _context.abrupt(\"continue\", 25);\n            case 17:\n              if (!(ctx === null)) {\n                _context.next = 20;\n                break;\n              }\n              // handle `null` context, nothing to cache\n              allResolved.push(new ResolvedContext({\n                document: null\n              }));\n              return _context.abrupt(\"continue\", 25);\n            case 20:\n              if (!_isObject(ctx)) {\n                _throwInvalidLocalContext(context);\n              }\n              // context is an object, get/create `ResolvedContext` for it\n              key = JSON.stringify(ctx);\n              resolved = this._get(key);\n              if (!resolved) {\n                // create a new static `ResolvedContext` and cache it\n                resolved = new ResolvedContext({\n                  document: ctx\n                });\n                this._cacheResolvedContext({\n                  key: key,\n                  resolved: resolved,\n                  tag: 'static'\n                });\n              }\n              allResolved.push(resolved);\n            case 25:\n              _context.next = 7;\n              break;\n            case 27:\n              _context.next = 32;\n              break;\n            case 29:\n              _context.prev = 29;\n              _context.t0 = _context[\"catch\"](5);\n              _iterator.e(_context.t0);\n            case 32:\n              _context.prev = 32;\n              _iterator.f();\n              return _context.finish(32);\n            case 35:\n              return _context.abrupt(\"return\", allResolved);\n            case 36:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this, [[5, 29, 32, 35]]);\n      }));\n      function resolve(_x) {\n        return _resolve.apply(this, arguments);\n      }\n      return resolve;\n    }()\n  }, {\n    key: \"_get\",\n    value: function _get(key) {\n      // get key from per operation cache; no `tag` is used with this cache so\n      // any retrieved context will always be the same during a single operation\n      var resolved = this.perOpCache.get(key);\n      if (!resolved) {\n        // see if the shared cache has a `static` entry for this URL\n        var tagMap = this.sharedCache.get(key);\n        if (tagMap) {\n          resolved = tagMap.get('static');\n          if (resolved) {\n            this.perOpCache.set(key, resolved);\n          }\n        }\n      }\n      return resolved;\n    }\n  }, {\n    key: \"_cacheResolvedContext\",\n    value: function _cacheResolvedContext(_ref3) {\n      var key = _ref3.key,\n        resolved = _ref3.resolved,\n        tag = _ref3.tag;\n      this.perOpCache.set(key, resolved);\n      if (tag !== undefined) {\n        var tagMap = this.sharedCache.get(key);\n        if (!tagMap) {\n          tagMap = new Map();\n          this.sharedCache.set(key, tagMap);\n        }\n        tagMap.set(tag, resolved);\n      }\n      return resolved;\n    }\n  }, {\n    key: \"_resolveRemoteContext\",\n    value: function () {\n      var _resolveRemoteContext2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(_ref4) {\n        var activeCtx, url, documentLoader, base, cycles, _yield$this$_fetchCon, context, remoteDoc, resolved;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              activeCtx = _ref4.activeCtx, url = _ref4.url, documentLoader = _ref4.documentLoader, base = _ref4.base, cycles = _ref4.cycles;\n              // resolve relative URL and fetch context\n              url = prependBase(base, url);\n              _context2.next = 4;\n              return this._fetchContext({\n                activeCtx: activeCtx,\n                url: url,\n                documentLoader: documentLoader,\n                cycles: cycles\n              });\n            case 4:\n              _yield$this$_fetchCon = _context2.sent;\n              context = _yield$this$_fetchCon.context;\n              remoteDoc = _yield$this$_fetchCon.remoteDoc;\n              // update base according to remote document and resolve any relative URLs\n              base = remoteDoc.documentUrl || url;\n              _resolveContextUrls({\n                context: context,\n                base: base\n              });\n\n              // resolve, cache, and return context\n              _context2.next = 11;\n              return this.resolve({\n                activeCtx: activeCtx,\n                context: context,\n                documentLoader: documentLoader,\n                base: base,\n                cycles: cycles\n              });\n            case 11:\n              resolved = _context2.sent;\n              this._cacheResolvedContext({\n                key: url,\n                resolved: resolved,\n                tag: remoteDoc.tag\n              });\n              return _context2.abrupt(\"return\", resolved);\n            case 14:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, this);\n      }));\n      function _resolveRemoteContext(_x2) {\n        return _resolveRemoteContext2.apply(this, arguments);\n      }\n      return _resolveRemoteContext;\n    }()\n  }, {\n    key: \"_fetchContext\",\n    value: function () {\n      var _fetchContext2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(_ref5) {\n        var activeCtx, url, documentLoader, cycles, context, remoteDoc;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) switch (_context3.prev = _context3.next) {\n            case 0:\n              activeCtx = _ref5.activeCtx, url = _ref5.url, documentLoader = _ref5.documentLoader, cycles = _ref5.cycles;\n              if (!(cycles.size > MAX_CONTEXT_URLS)) {\n                _context3.next = 3;\n                break;\n              }\n              throw new JsonLdError('Maximum number of @context URLs exceeded.', 'jsonld.ContextUrlError', {\n                code: activeCtx.processingMode === 'json-ld-1.0' ? 'loading remote context failed' : 'context overflow',\n                max: MAX_CONTEXT_URLS\n              });\n            case 3:\n              if (!cycles.has(url)) {\n                _context3.next = 5;\n                break;\n              }\n              throw new JsonLdError('Cyclical @context URLs detected.', 'jsonld.ContextUrlError', {\n                code: activeCtx.processingMode === 'json-ld-1.0' ? 'recursive context inclusion' : 'context overflow',\n                url: url\n              });\n            case 5:\n              // track cycles\n              cycles.add(url);\n              _context3.prev = 6;\n              _context3.next = 9;\n              return documentLoader(url);\n            case 9:\n              remoteDoc = _context3.sent;\n              context = remoteDoc.document || null;\n              // parse string context as JSON\n              if (_isString(context)) {\n                context = JSON.parse(context);\n              }\n              _context3.next = 17;\n              break;\n            case 14:\n              _context3.prev = 14;\n              _context3.t0 = _context3[\"catch\"](6);\n              throw new JsonLdError('Dereferencing a URL did not result in a valid JSON-LD object. ' + 'Possible causes are an inaccessible URL perhaps due to ' + 'a same-origin policy (ensure the server uses CORS if you are ' + 'using client-side JavaScript), too many redirects, a ' + 'non-JSON response, or more than one HTTP Link Header was ' + 'provided for a remote context.', 'jsonld.InvalidUrl', {\n                code: 'loading remote context failed',\n                url: url,\n                cause: _context3.t0\n              });\n            case 17:\n              if (_isObject(context)) {\n                _context3.next = 19;\n                break;\n              }\n              throw new JsonLdError('Dereferencing a URL did not result in a JSON object. The ' + 'response was valid JSON, but it was not a JSON object.', 'jsonld.InvalidUrl', {\n                code: 'invalid remote context',\n                url: url\n              });\n            case 19:\n              // use empty context if no @context key is present\n              if (!('@context' in context)) {\n                context = {\n                  '@context': {}\n                };\n              } else {\n                context = {\n                  '@context': context['@context']\n                };\n              }\n\n              // append @context URL to context if given\n              if (remoteDoc.contextUrl) {\n                if (!_isArray(context['@context'])) {\n                  context['@context'] = [context['@context']];\n                }\n                context['@context'].push(remoteDoc.contextUrl);\n              }\n              return _context3.abrupt(\"return\", {\n                context: context,\n                remoteDoc: remoteDoc\n              });\n            case 22:\n            case \"end\":\n              return _context3.stop();\n          }\n        }, _callee3, null, [[6, 14]]);\n      }));\n      function _fetchContext(_x3) {\n        return _fetchContext2.apply(this, arguments);\n      }\n      return _fetchContext;\n    }()\n  }]);\n  return ContextResolver;\n}();\nfunction _throwInvalidLocalContext(ctx) {\n  throw new JsonLdError('Invalid JSON-LD syntax; @context must be an object.', 'jsonld.SyntaxError', {\n    code: 'invalid local context',\n    context: ctx\n  });\n}\n\n/**\n * Resolve all relative `@context` URLs in the given context by inline\n * replacing them with absolute URLs.\n *\n * @param context the context.\n * @param base the base IRI to use to resolve relative IRIs.\n */\nfunction _resolveContextUrls(_ref6) {\n  var context = _ref6.context,\n    base = _ref6.base;\n  if (!context) {\n    return;\n  }\n  var ctx = context['@context'];\n  if (_isString(ctx)) {\n    context['@context'] = prependBase(base, ctx);\n    return;\n  }\n  if (_isArray(ctx)) {\n    for (var i = 0; i < ctx.length; ++i) {\n      var element = ctx[i];\n      if (_isString(element)) {\n        ctx[i] = prependBase(base, element);\n        continue;\n      }\n      if (_isObject(element)) {\n        _resolveContextUrls({\n          context: {\n            '@context': element\n          },\n          base: base\n        });\n      }\n    }\n    return;\n  }\n  if (!_isObject(ctx)) {\n    // no @context URLs can be found in non-object\n    return;\n  }\n\n  // ctx is an object, resolve any context URLs in terms\n  for (var term in ctx) {\n    _resolveContextUrls({\n      context: ctx[term],\n      base: base\n    });\n  }\n}","map":{"version":3,"names":["require","_isArray","isArray","_isObject","isObject","_isString","isString","_asArray","asArray","prependBase","JsonLdError","ResolvedContext","MAX_CONTEXT_URLS","module","exports","sharedCache","perOpCache","Map","activeCtx","context","documentLoader","base","cycles","Set","allResolved","ctx","resolved","_get","_resolveRemoteContext","url","push","document","_throwInvalidLocalContext","key","JSON","stringify","_cacheResolvedContext","tag","get","tagMap","set","undefined","_fetchContext","remoteDoc","documentUrl","_resolveContextUrls","resolve","size","code","processingMode","max","has","add","parse","cause","contextUrl","i","length","element","term"],"sources":["/home/jean-daniel/Documents/Projets/DÃ©veloppement/ActivityPods/BCM/frontend/node_modules/jsonld/lib/ContextResolver.js"],"sourcesContent":["/*\n * Copyright (c) 2019 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nconst {\n  isArray: _isArray,\n  isObject: _isObject,\n  isString: _isString,\n} = require('./types');\nconst {\n  asArray: _asArray\n} = require('./util');\nconst {prependBase} = require('./url');\nconst JsonLdError = require('./JsonLdError');\nconst ResolvedContext = require('./ResolvedContext');\n\nconst MAX_CONTEXT_URLS = 10;\n\nmodule.exports = class ContextResolver {\n  /**\n   * Creates a ContextResolver.\n   *\n   * @param sharedCache a shared LRU cache with `get` and `set` APIs.\n   */\n  constructor({sharedCache}) {\n    this.perOpCache = new Map();\n    this.sharedCache = sharedCache;\n  }\n\n  async resolve({\n    activeCtx, context, documentLoader, base, cycles = new Set()\n  }) {\n    // process `@context`\n    if(context && _isObject(context) && context['@context']) {\n      context = context['@context'];\n    }\n\n    // context is one or more contexts\n    context = _asArray(context);\n\n    // resolve each context in the array\n    const allResolved = [];\n    for(const ctx of context) {\n      if(_isString(ctx)) {\n        // see if `ctx` has been resolved before...\n        let resolved = this._get(ctx);\n        if(!resolved) {\n          // not resolved yet, resolve\n          resolved = await this._resolveRemoteContext(\n            {activeCtx, url: ctx, documentLoader, base, cycles});\n        }\n\n        // add to output and continue\n        if(_isArray(resolved)) {\n          allResolved.push(...resolved);\n        } else {\n          allResolved.push(resolved);\n        }\n        continue;\n      }\n      if(ctx === null) {\n        // handle `null` context, nothing to cache\n        allResolved.push(new ResolvedContext({document: null}));\n        continue;\n      }\n      if(!_isObject(ctx)) {\n        _throwInvalidLocalContext(context);\n      }\n      // context is an object, get/create `ResolvedContext` for it\n      const key = JSON.stringify(ctx);\n      let resolved = this._get(key);\n      if(!resolved) {\n        // create a new static `ResolvedContext` and cache it\n        resolved = new ResolvedContext({document: ctx});\n        this._cacheResolvedContext({key, resolved, tag: 'static'});\n      }\n      allResolved.push(resolved);\n    }\n\n    return allResolved;\n  }\n\n  _get(key) {\n    // get key from per operation cache; no `tag` is used with this cache so\n    // any retrieved context will always be the same during a single operation\n    let resolved = this.perOpCache.get(key);\n    if(!resolved) {\n      // see if the shared cache has a `static` entry for this URL\n      const tagMap = this.sharedCache.get(key);\n      if(tagMap) {\n        resolved = tagMap.get('static');\n        if(resolved) {\n          this.perOpCache.set(key, resolved);\n        }\n      }\n    }\n    return resolved;\n  }\n\n  _cacheResolvedContext({key, resolved, tag}) {\n    this.perOpCache.set(key, resolved);\n    if(tag !== undefined) {\n      let tagMap = this.sharedCache.get(key);\n      if(!tagMap) {\n        tagMap = new Map();\n        this.sharedCache.set(key, tagMap);\n      }\n      tagMap.set(tag, resolved);\n    }\n    return resolved;\n  }\n\n  async _resolveRemoteContext({activeCtx, url, documentLoader, base, cycles}) {\n    // resolve relative URL and fetch context\n    url = prependBase(base, url);\n    const {context, remoteDoc} = await this._fetchContext(\n      {activeCtx, url, documentLoader, cycles});\n\n    // update base according to remote document and resolve any relative URLs\n    base = remoteDoc.documentUrl || url;\n    _resolveContextUrls({context, base});\n\n    // resolve, cache, and return context\n    const resolved = await this.resolve(\n      {activeCtx, context, documentLoader, base, cycles});\n    this._cacheResolvedContext({key: url, resolved, tag: remoteDoc.tag});\n    return resolved;\n  }\n\n  async _fetchContext({activeCtx, url, documentLoader, cycles}) {\n    // check for max context URLs fetched during a resolve operation\n    if(cycles.size > MAX_CONTEXT_URLS) {\n      throw new JsonLdError(\n        'Maximum number of @context URLs exceeded.',\n        'jsonld.ContextUrlError',\n        {\n          code: activeCtx.processingMode === 'json-ld-1.0' ?\n            'loading remote context failed' :\n            'context overflow',\n          max: MAX_CONTEXT_URLS\n        });\n    }\n\n    // check for context URL cycle\n    // shortcut to avoid extra work that would eventually hit the max above\n    if(cycles.has(url)) {\n      throw new JsonLdError(\n        'Cyclical @context URLs detected.',\n        'jsonld.ContextUrlError',\n        {\n          code: activeCtx.processingMode === 'json-ld-1.0' ?\n            'recursive context inclusion' :\n            'context overflow',\n          url\n        });\n    }\n\n    // track cycles\n    cycles.add(url);\n\n    let context;\n    let remoteDoc;\n\n    try {\n      remoteDoc = await documentLoader(url);\n      context = remoteDoc.document || null;\n      // parse string context as JSON\n      if(_isString(context)) {\n        context = JSON.parse(context);\n      }\n    } catch(e) {\n      throw new JsonLdError(\n        'Dereferencing a URL did not result in a valid JSON-LD object. ' +\n        'Possible causes are an inaccessible URL perhaps due to ' +\n        'a same-origin policy (ensure the server uses CORS if you are ' +\n        'using client-side JavaScript), too many redirects, a ' +\n        'non-JSON response, or more than one HTTP Link Header was ' +\n        'provided for a remote context.',\n        'jsonld.InvalidUrl',\n        {code: 'loading remote context failed', url, cause: e});\n    }\n\n    // ensure ctx is an object\n    if(!_isObject(context)) {\n      throw new JsonLdError(\n        'Dereferencing a URL did not result in a JSON object. The ' +\n        'response was valid JSON, but it was not a JSON object.',\n        'jsonld.InvalidUrl', {code: 'invalid remote context', url});\n    }\n\n    // use empty context if no @context key is present\n    if(!('@context' in context)) {\n      context = {'@context': {}};\n    } else {\n      context = {'@context': context['@context']};\n    }\n\n    // append @context URL to context if given\n    if(remoteDoc.contextUrl) {\n      if(!_isArray(context['@context'])) {\n        context['@context'] = [context['@context']];\n      }\n      context['@context'].push(remoteDoc.contextUrl);\n    }\n\n    return {context, remoteDoc};\n  }\n};\n\nfunction _throwInvalidLocalContext(ctx) {\n  throw new JsonLdError(\n    'Invalid JSON-LD syntax; @context must be an object.',\n    'jsonld.SyntaxError', {\n      code: 'invalid local context', context: ctx\n    });\n}\n\n/**\n * Resolve all relative `@context` URLs in the given context by inline\n * replacing them with absolute URLs.\n *\n * @param context the context.\n * @param base the base IRI to use to resolve relative IRIs.\n */\nfunction _resolveContextUrls({context, base}) {\n  if(!context) {\n    return;\n  }\n\n  const ctx = context['@context'];\n\n  if(_isString(ctx)) {\n    context['@context'] = prependBase(base, ctx);\n    return;\n  }\n\n  if(_isArray(ctx)) {\n    for(let i = 0; i < ctx.length; ++i) {\n      const element = ctx[i];\n      if(_isString(element)) {\n        ctx[i] = prependBase(base, element);\n        continue;\n      }\n      if(_isObject(element)) {\n        _resolveContextUrls({context: {'@context': element}, base});\n      }\n    }\n    return;\n  }\n\n  if(!_isObject(ctx)) {\n    // no @context URLs can be found in non-object\n    return;\n  }\n\n  // ctx is an object, resolve any context URLs in terms\n  for(const term in ctx) {\n    _resolveContextUrls({context: ctx[term], base});\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}