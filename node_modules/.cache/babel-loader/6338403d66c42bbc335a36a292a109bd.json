{"ast":null,"code":"var XSD_INTEGER = 'http://www.w3.org/2001/XMLSchema#integer';\nvar XSD_STRING = 'http://www.w3.org/2001/XMLSchema#string';\nfunction Generator(options) {\n  this._options = options = options || {};\n  var prefixes = options.prefixes || {};\n  this._prefixByIri = {};\n  var prefixIris = [];\n  for (var prefix in prefixes) {\n    var iri = prefixes[prefix];\n    if (isString(iri)) {\n      this._prefixByIri[iri] = prefix;\n      prefixIris.push(iri);\n    }\n  }\n  var iriList = prefixIris.join('|').replace(/[\\]\\/\\(\\)\\*\\+\\?\\.\\\\\\$]/g, '\\\\$&');\n  this._prefixRegex = new RegExp('^(' + iriList + ')([a-zA-Z][\\\\-_a-zA-Z0-9]*)$');\n  this._usedPrefixes = {};\n  this._sparqlStar = options.sparqlStar;\n  this._indent = isString(options.indent) ? options.indent : '  ';\n  this._newline = isString(options.newline) ? options.newline : '\\n';\n  this._explicitDatatype = Boolean(options.explicitDatatype);\n}\n\n// Converts the parsed query object into a SPARQL query\nGenerator.prototype.toQuery = function (q) {\n  var query = '';\n  if (q.queryType) query += q.queryType.toUpperCase() + ' ';\n  if (q.reduced) query += 'REDUCED ';\n  if (q.distinct) query += 'DISTINCT ';\n  if (q.variables) {\n    query += mapJoin(q.variables, undefined, function (variable) {\n      return isTerm(variable) ? this.toEntity(variable) : '(' + this.toExpression(variable.expression) + ' AS ' + variableToString(variable.variable) + ')';\n    }, this) + ' ';\n  } else if (q.template) query += this.group(q.template, true) + this._newline;\n  if (q.from) query += this.graphs('FROM ', q.from.default) + this.graphs('FROM NAMED ', q.from.named);\n  if (q.where) query += 'WHERE ' + this.group(q.where, true) + this._newline;\n  if (q.updates) query += mapJoin(q.updates, ';' + this._newline, this.toUpdate, this);\n  if (q.group) query += 'GROUP BY ' + mapJoin(q.group, undefined, function (it) {\n    var result = isTerm(it.expression) ? this.toEntity(it.expression) : '(' + this.toExpression(it.expression) + ')';\n    return it.variable ? '(' + result + ' AS ' + variableToString(it.variable) + ')' : result;\n  }, this) + this._newline;\n  if (q.having) query += 'HAVING (' + mapJoin(q.having, undefined, this.toExpression, this) + ')' + this._newline;\n  if (q.order) query += 'ORDER BY ' + mapJoin(q.order, undefined, function (it) {\n    var expr = '(' + this.toExpression(it.expression) + ')';\n    return !it.descending ? expr : 'DESC ' + expr;\n  }, this) + this._newline;\n  if (q.offset) query += 'OFFSET ' + q.offset + this._newline;\n  if (q.limit) query += 'LIMIT ' + q.limit + this._newline;\n  if (q.values) query += this.values(q);\n\n  // stringify prefixes at the end to mark used ones\n  query = this.baseAndPrefixes(q) + query;\n  return query.trim();\n};\nGenerator.prototype.baseAndPrefixes = function (q) {\n  var base = q.base ? 'BASE <' + q.base + '>' + this._newline : '';\n  var prefixes = '';\n  for (var key in q.prefixes) {\n    if (this._options.allPrefixes || this._usedPrefixes[key]) prefixes += 'PREFIX ' + key + ': <' + q.prefixes[key] + '>' + this._newline;\n  }\n  return base + prefixes;\n};\n\n// Converts the parsed SPARQL pattern into a SPARQL pattern\nGenerator.prototype.toPattern = function (pattern) {\n  var type = pattern.type || pattern instanceof Array && 'array' || (pattern.subject && pattern.predicate && pattern.object ? 'triple' : '');\n  if (!(type in this)) throw new Error('Unknown entry type: ' + type);\n  return this[type](pattern);\n};\nGenerator.prototype.triple = function (t) {\n  return this.toEntity(t.subject) + ' ' + this.toEntity(t.predicate) + ' ' + this.toEntity(t.object) + '.';\n};\nGenerator.prototype.array = function (items) {\n  return mapJoin(items, this._newline, this.toPattern, this);\n};\nGenerator.prototype.bgp = function (bgp) {\n  return this.encodeTriples(bgp.triples);\n};\nGenerator.prototype.encodeTriples = function (triples) {\n  if (!triples.length) return '';\n  var parts = [],\n    subject = undefined,\n    predicate = undefined;\n  for (var i = 0; i < triples.length; i++) {\n    var triple = triples[i];\n    // Triple with different subject\n    if (!equalTerms(triple.subject, subject)) {\n      // Terminate previous triple\n      if (subject) parts.push('.' + this._newline);\n      subject = triple.subject;\n      predicate = triple.predicate;\n      parts.push(this.toEntity(subject), ' ', this.toEntity(predicate));\n    }\n    // Triple with same subject but different predicate\n    else if (!equalTerms(triple.predicate, predicate)) {\n      predicate = triple.predicate;\n      parts.push(';' + this._newline, this._indent, this.toEntity(predicate));\n    }\n    // Triple with same subject and predicate\n    else {\n      parts.push(',');\n    }\n    parts.push(' ', this.toEntity(triple.object));\n  }\n  parts.push('.');\n  return parts.join('');\n};\nGenerator.prototype.graph = function (graph) {\n  return 'GRAPH ' + this.toEntity(graph.name) + ' ' + this.group(graph);\n};\nGenerator.prototype.graphs = function (keyword, graphs) {\n  return !graphs || graphs.length === 0 ? '' : mapJoin(graphs, '', function (g) {\n    return keyword + this.toEntity(g) + this._newline;\n  }, this);\n};\nGenerator.prototype.group = function (group, inline) {\n  group = inline !== true ? this.array(group.patterns || group.triples) : this.toPattern(group.type !== 'group' ? group : group.patterns);\n  return group.indexOf(this._newline) === -1 ? '{ ' + group + ' }' : '{' + this._newline + this.indent(group) + this._newline + '}';\n};\nGenerator.prototype.query = function (query) {\n  return this.toQuery(query);\n};\nGenerator.prototype.filter = function (filter) {\n  return 'FILTER(' + this.toExpression(filter.expression) + ')';\n};\nGenerator.prototype.bind = function (bind) {\n  return 'BIND(' + this.toExpression(bind.expression) + ' AS ' + variableToString(bind.variable) + ')';\n};\nGenerator.prototype.optional = function (optional) {\n  return 'OPTIONAL ' + this.group(optional);\n};\nGenerator.prototype.union = function (union) {\n  return mapJoin(union.patterns, this._newline + 'UNION' + this._newline, function (p) {\n    return this.group(p, true);\n  }, this);\n};\nGenerator.prototype.minus = function (minus) {\n  return 'MINUS ' + this.group(minus);\n};\nGenerator.prototype.values = function (valuesList) {\n  // Gather unique keys\n  var keys = Object.keys(valuesList.values.reduce(function (keyHash, values) {\n    for (var key in values) keyHash[key] = true;\n    return keyHash;\n  }, {}));\n  // Check whether simple syntax can be used\n  var lparen, rparen;\n  if (keys.length === 1) {\n    lparen = rparen = '';\n  } else {\n    lparen = '(';\n    rparen = ')';\n  }\n  // Create value rows\n  return 'VALUES ' + lparen + keys.join(' ') + rparen + ' {' + this._newline + mapJoin(valuesList.values, this._newline, function (values) {\n    return '  ' + lparen + mapJoin(keys, undefined, function (key) {\n      return values[key] ? this.toEntity(values[key]) : 'UNDEF';\n    }, this) + rparen;\n  }, this) + this._newline + '}';\n};\nGenerator.prototype.service = function (service) {\n  return 'SERVICE ' + (service.silent ? 'SILENT ' : '') + this.toEntity(service.name) + ' ' + this.group(service);\n};\n\n// Converts the parsed expression object into a SPARQL expression\nGenerator.prototype.toExpression = function (expr) {\n  if (isTerm(expr)) {\n    return this.toEntity(expr);\n  }\n  switch (expr.type.toLowerCase()) {\n    case 'aggregate':\n      return expr.aggregation.toUpperCase() + '(' + (expr.distinct ? 'DISTINCT ' : '') + this.toExpression(expr.expression) + (typeof expr.separator === 'string' ? '; SEPARATOR = ' + '\"' + expr.separator.replace(escape, escapeReplacer) + '\"' : '') + ')';\n    case 'functioncall':\n      return this.toEntity(expr.function) + '(' + mapJoin(expr.args, ', ', this.toExpression, this) + ')';\n    case 'operation':\n      var operator = expr.operator.toUpperCase(),\n        args = expr.args || [];\n      switch (expr.operator.toLowerCase()) {\n        // Infix operators\n        case '<':\n        case '>':\n        case '>=':\n        case '<=':\n        case '&&':\n        case '||':\n        case '=':\n        case '!=':\n        case '+':\n        case '-':\n        case '*':\n        case '/':\n          return (isTerm(args[0]) ? this.toEntity(args[0]) : '(' + this.toExpression(args[0]) + ')') + ' ' + operator + ' ' + (isTerm(args[1]) ? this.toEntity(args[1]) : '(' + this.toExpression(args[1]) + ')');\n        // Unary operators\n        case '!':\n          return '!(' + this.toExpression(args[0]) + ')';\n        case 'uplus':\n          return '+(' + this.toExpression(args[0]) + ')';\n        case 'uminus':\n          return '-(' + this.toExpression(args[0]) + ')';\n        // IN and NOT IN\n        case 'notin':\n          operator = 'NOT IN';\n        case 'in':\n          return this.toExpression(args[0]) + ' ' + operator + '(' + (isString(args[1]) ? args[1] : mapJoin(args[1], ', ', this.toExpression, this)) + ')';\n        // EXISTS and NOT EXISTS\n        case 'notexists':\n          operator = 'NOT EXISTS';\n        case 'exists':\n          return operator + ' ' + this.group(args[0], true);\n        // Other expressions\n        default:\n          return operator + '(' + mapJoin(args, ', ', this.toExpression, this) + ')';\n      }\n    default:\n      throw new Error('Unknown expression type: ' + expr.type);\n  }\n};\n\n// Converts the parsed entity (or property path) into a SPARQL entity\nGenerator.prototype.toEntity = function (value) {\n  if (isTerm(value)) {\n    switch (value.termType) {\n      // variable, * selector, or blank node\n      case 'Wildcard':\n        return '*';\n      case 'Variable':\n        return variableToString(value);\n      case 'BlankNode':\n        return '_:' + value.value;\n      // literal\n      case 'Literal':\n        var lexical = value.value || '',\n          language = value.language || '',\n          datatype = value.datatype;\n        value = '\"' + lexical.replace(escape, escapeReplacer) + '\"';\n        if (language) {\n          value += '@' + language;\n        } else if (datatype) {\n          // Abbreviate literals when possible\n          if (!this._explicitDatatype) {\n            switch (datatype.value) {\n              case XSD_STRING:\n                return value;\n              case XSD_INTEGER:\n                if (/^\\d+$/.test(lexical))\n                  // Add space to avoid confusion with decimals in broken parsers\n                  return lexical + ' ';\n            }\n          }\n          value += '^^' + this.encodeIRI(datatype.value);\n        }\n        return value;\n      case 'Quad':\n        if (!this._sparqlStar) throw new Error('SPARQL* support is not enabled');\n        if (value.graph && value.graph.termType !== \"DefaultGraph\") {\n          return '<< GRAPH ' + this.toEntity(value.graph) + ' { ' + this.toEntity(value.subject) + ' ' + this.toEntity(value.predicate) + ' ' + this.toEntity(value.object) + ' } ' + ' >>';\n        } else {\n          return '<< ' + this.toEntity(value.subject) + ' ' + this.toEntity(value.predicate) + ' ' + this.toEntity(value.object) + ' >>';\n        }\n      // IRI\n      default:\n        return this.encodeIRI(value.value);\n    }\n  }\n  // property path\n  else {\n    var items = value.items.map(this.toEntity, this),\n      path = value.pathType;\n    switch (path) {\n      // prefix operator\n      case '^':\n      case '!':\n        return path + items[0];\n      // postfix operator\n      case '*':\n      case '+':\n      case '?':\n        return '(' + items[0] + path + ')';\n      // infix operator\n      default:\n        return '(' + items.join(path) + ')';\n    }\n  }\n};\nvar escape = /[\"\\\\\\t\\n\\r\\b\\f]/g,\n  escapeReplacer = function escapeReplacer(c) {\n    return escapeReplacements[c];\n  },\n  escapeReplacements = {\n    '\\\\': '\\\\\\\\',\n    '\"': '\\\\\"',\n    '\\t': '\\\\t',\n    '\\n': '\\\\n',\n    '\\r': '\\\\r',\n    '\\b': '\\\\b',\n    '\\f': '\\\\f'\n  };\n\n// Represent the IRI, as a prefixed name when possible\nGenerator.prototype.encodeIRI = function (iri) {\n  var prefixMatch = this._prefixRegex.exec(iri);\n  if (prefixMatch) {\n    var prefix = this._prefixByIri[prefixMatch[1]];\n    this._usedPrefixes[prefix] = true;\n    return prefix + ':' + prefixMatch[2];\n  }\n  return '<' + iri + '>';\n};\n\n// Converts the parsed update object into a SPARQL update clause\nGenerator.prototype.toUpdate = function (update) {\n  switch (update.type || update.updateType) {\n    case 'load':\n      return 'LOAD' + (update.source ? ' ' + this.toEntity(update.source) : '') + (update.destination ? ' INTO GRAPH ' + this.toEntity(update.destination) : '');\n    case 'insert':\n      return 'INSERT DATA ' + this.group(update.insert, true);\n    case 'delete':\n      return 'DELETE DATA ' + this.group(update.delete, true);\n    case 'deletewhere':\n      return 'DELETE WHERE ' + this.group(update.delete, true);\n    case 'insertdelete':\n      return (update.graph ? 'WITH ' + this.toEntity(update.graph) + this._newline : '') + (update.delete.length ? 'DELETE ' + this.group(update.delete, true) + this._newline : '') + (update.insert.length ? 'INSERT ' + this.group(update.insert, true) + this._newline : '') + (update.using ? this.graphs('USING ', update.using.default) : '') + (update.using ? this.graphs('USING NAMED ', update.using.named) : '') + 'WHERE ' + this.group(update.where, true);\n    case 'add':\n    case 'copy':\n    case 'move':\n      return update.type.toUpperCase() + ' ' + (update.silent ? 'SILENT ' : '') + (update.source.default ? 'DEFAULT' : this.toEntity(update.source.name)) + ' TO ' + this.toEntity(update.destination.name);\n    case 'create':\n    case 'clear':\n    case 'drop':\n      return update.type.toUpperCase() + (update.silent ? ' SILENT ' : ' ') + (update.graph.default ? 'DEFAULT' : update.graph.named ? 'NAMED' : update.graph.all ? 'ALL' : 'GRAPH ' + this.toEntity(update.graph.name));\n    default:\n      throw new Error('Unknown update query type: ' + update.type);\n  }\n};\n\n// Indents each line of the string\nGenerator.prototype.indent = function (text) {\n  return text.replace(/^/gm, this._indent);\n};\nfunction variableToString(variable) {\n  return '?' + variable.value;\n}\n\n// Checks whether the object is a string\nfunction isString(object) {\n  return typeof object === 'string';\n}\n\n// Checks whether the object is a Term\nfunction isTerm(object) {\n  return typeof object.termType === 'string';\n}\n\n// Checks whether term1 and term2 are equivalent without `.equals()` prototype method\nfunction equalTerms(term1, term2) {\n  if (!term1 || !isTerm(term1)) {\n    return false;\n  }\n  if (!term2 || !isTerm(term2)) {\n    return false;\n  }\n  if (term1.termType !== term2.termType) {\n    return false;\n  }\n  switch (term1.termType) {\n    case 'Literal':\n      return term1.value === term2.value && term1.language === term2.language && equalTerms(term1.datatype, term2.datatype);\n    case 'Quad':\n      return equalTerms(term1.subject, term2.subject) && equalTerms(term1.predicate, term2.predicate) && equalTerms(term1.object, term2.object) && equalTerms(term1.graph, term2.graph);\n    default:\n      return term1.value === term2.value;\n  }\n}\n\n// Maps the array with the given function, and joins the results using the separator\nfunction mapJoin(array, sep, func, self) {\n  return array.map(func, self).join(isString(sep) ? sep : ' ');\n}\n\n/**\n * @param options {\n *   allPrefixes: boolean,\n *   indentation: string,\n *   newline: string\n * }\n */\nmodule.exports = function SparqlGenerator() {\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return {\n    stringify: function stringify(query) {\n      var currentOptions = Object.create(options);\n      currentOptions.prefixes = query.prefixes;\n      return new Generator(currentOptions).toQuery(query);\n    },\n    createGenerator: function createGenerator() {\n      return new Generator(options);\n    }\n  };\n};","map":{"version":3,"names":["XSD_INTEGER","XSD_STRING","Generator","options","_options","prefixes","_prefixByIri","prefixIris","prefix","iri","isString","push","iriList","join","replace","_prefixRegex","RegExp","_usedPrefixes","_sparqlStar","sparqlStar","_indent","indent","_newline","newline","_explicitDatatype","Boolean","explicitDatatype","prototype","toQuery","q","query","queryType","toUpperCase","reduced","distinct","variables","mapJoin","undefined","variable","isTerm","toEntity","toExpression","expression","variableToString","template","group","from","graphs","default","named","where","updates","toUpdate","it","result","having","order","expr","descending","offset","limit","values","baseAndPrefixes","trim","base","key","allPrefixes","toPattern","pattern","type","Array","subject","predicate","object","Error","triple","t","array","items","bgp","encodeTriples","triples","length","parts","i","equalTerms","graph","name","keyword","g","inline","patterns","indexOf","filter","bind","optional","union","p","minus","valuesList","keys","Object","reduce","keyHash","lparen","rparen","service","silent","toLowerCase","aggregation","separator","escape","escapeReplacer","function","args","operator","value","termType","lexical","language","datatype","test","encodeIRI","map","path","pathType","c","escapeReplacements","prefixMatch","exec","update","updateType","source","destination","insert","delete","using","all","text","term1","term2","sep","func","self","module","exports","SparqlGenerator","stringify","currentOptions","create","createGenerator"],"sources":["/home/jean-daniel/Documents/Projets/DÃ©veloppement/ActivityPods/BCM/frontend/node_modules/sparqljs/lib/SparqlGenerator.js"],"sourcesContent":["var XSD_INTEGER = 'http://www.w3.org/2001/XMLSchema#integer';\nvar XSD_STRING = 'http://www.w3.org/2001/XMLSchema#string';\n\nfunction Generator(options) {\n  this._options = options = options || {};\n\n  var prefixes = options.prefixes || {};\n  this._prefixByIri = {};\n  var prefixIris = [];\n  for (var prefix in prefixes) {\n    var iri = prefixes[prefix];\n    if (isString(iri)) {\n      this._prefixByIri[iri] = prefix;\n      prefixIris.push(iri);\n    }\n  }\n  var iriList = prefixIris.join('|').replace(/[\\]\\/\\(\\)\\*\\+\\?\\.\\\\\\$]/g, '\\\\$&');\n  this._prefixRegex = new RegExp('^(' + iriList + ')([a-zA-Z][\\\\-_a-zA-Z0-9]*)$');\n  this._usedPrefixes = {};\n  this._sparqlStar = options.sparqlStar;\n  this._indent =  isString(options.indent)  ? options.indent  : '  ';\n  this._newline = isString(options.newline) ? options.newline : '\\n';\n  this._explicitDatatype = Boolean(options.explicitDatatype);\n}\n\n// Converts the parsed query object into a SPARQL query\nGenerator.prototype.toQuery = function (q) {\n  var query = '';\n\n  if (q.queryType)\n    query += q.queryType.toUpperCase() + ' ';\n  if (q.reduced)\n    query += 'REDUCED ';\n  if (q.distinct)\n    query += 'DISTINCT ';\n\n  if (q.variables){\n    query += mapJoin(q.variables, undefined, function (variable) {\n      return isTerm(variable) ? this.toEntity(variable) :\n             '(' + this.toExpression(variable.expression) + ' AS ' + variableToString(variable.variable) + ')';\n    }, this) + ' ';\n  }\n  else if (q.template)\n    query += this.group(q.template, true) + this._newline;\n\n  if (q.from)\n    query += this.graphs('FROM ', q.from.default) + this.graphs('FROM NAMED ', q.from.named);\n  if (q.where)\n    query += 'WHERE ' + this.group(q.where, true) + this._newline;\n\n  if (q.updates)\n    query += mapJoin(q.updates, ';' + this._newline, this.toUpdate, this);\n\n  if (q.group)\n    query += 'GROUP BY ' + mapJoin(q.group, undefined, function (it) {\n      var result = isTerm(it.expression)\n        ? this.toEntity(it.expression)\n        : '(' + this.toExpression(it.expression) + ')';\n      return it.variable ? '(' + result + ' AS ' + variableToString(it.variable) + ')' : result;\n    }, this) + this._newline;\n  if (q.having)\n    query += 'HAVING (' + mapJoin(q.having, undefined, this.toExpression, this) + ')' + this._newline;\n  if (q.order)\n    query += 'ORDER BY ' + mapJoin(q.order, undefined, function (it) {\n      var expr = '(' + this.toExpression(it.expression) + ')';\n      return !it.descending ? expr : 'DESC ' + expr;\n    }, this) + this._newline;\n\n  if (q.offset)\n    query += 'OFFSET ' + q.offset + this._newline;\n  if (q.limit)\n    query += 'LIMIT ' + q.limit + this._newline;\n\n  if (q.values)\n    query += this.values(q);\n\n  // stringify prefixes at the end to mark used ones\n  query = this.baseAndPrefixes(q) + query;\n  return query.trim();\n};\n\nGenerator.prototype.baseAndPrefixes = function (q) {\n  var base = q.base ? ('BASE <' + q.base + '>' + this._newline) : '';\n  var prefixes = '';\n  for (var key in q.prefixes) {\n    if (this._options.allPrefixes || this._usedPrefixes[key])\n      prefixes += 'PREFIX ' + key + ': <' + q.prefixes[key] + '>' + this._newline;\n  }\n  return base + prefixes;\n};\n\n// Converts the parsed SPARQL pattern into a SPARQL pattern\nGenerator.prototype.toPattern = function (pattern) {\n  var type = pattern.type || (pattern instanceof Array) && 'array' ||\n             (pattern.subject && pattern.predicate && pattern.object ? 'triple' : '');\n  if (!(type in this))\n    throw new Error('Unknown entry type: ' + type);\n  return this[type](pattern);\n};\n\nGenerator.prototype.triple = function (t) {\n  return this.toEntity(t.subject) + ' ' + this.toEntity(t.predicate) + ' ' + this.toEntity(t.object) + '.';\n};\n\nGenerator.prototype.array = function (items) {\n  return mapJoin(items, this._newline, this.toPattern, this);\n};\n\nGenerator.prototype.bgp = function (bgp) {\n  return this.encodeTriples(bgp.triples);\n};\n\nGenerator.prototype.encodeTriples = function (triples) {\n  if (!triples.length)\n    return '';\n\n  var parts = [], subject = undefined, predicate = undefined;\n  for (var i = 0; i < triples.length; i++) {\n    var triple = triples[i];\n    // Triple with different subject\n    if (!equalTerms(triple.subject, subject)) {\n      // Terminate previous triple\n      if (subject)\n        parts.push('.' + this._newline);\n      subject = triple.subject;\n      predicate = triple.predicate;\n      parts.push(this.toEntity(subject), ' ', this.toEntity(predicate));\n    }\n    // Triple with same subject but different predicate\n    else if (!equalTerms(triple.predicate, predicate)) {\n      predicate = triple.predicate;\n      parts.push(';' + this._newline, this._indent, this.toEntity(predicate));\n    }\n    // Triple with same subject and predicate\n    else {\n      parts.push(',');\n    }\n    parts.push(' ', this.toEntity(triple.object));\n  }\n  parts.push('.');\n\n  return parts.join('');\n}\n\nGenerator.prototype.graph = function (graph) {\n  return 'GRAPH ' + this.toEntity(graph.name) + ' ' + this.group(graph);\n};\n\nGenerator.prototype.graphs = function (keyword, graphs) {\n  return !graphs || graphs.length === 0 ? '' :\n    mapJoin(graphs, '', function (g) { return keyword + this.toEntity(g) + this._newline; }, this)\n}\n\nGenerator.prototype.group = function (group, inline) {\n  group = inline !== true ? this.array(group.patterns || group.triples)\n                          : this.toPattern(group.type !== 'group' ? group : group.patterns);\n  return group.indexOf(this._newline) === -1 ? '{ ' + group + ' }' : '{' + this._newline + this.indent(group) + this._newline + '}';\n};\n\nGenerator.prototype.query = function (query) {\n  return this.toQuery(query);\n};\n\nGenerator.prototype.filter = function (filter) {\n  return 'FILTER(' + this.toExpression(filter.expression) + ')';\n};\n\nGenerator.prototype.bind = function (bind) {\n  return 'BIND(' + this.toExpression(bind.expression) + ' AS ' + variableToString(bind.variable) + ')';\n};\n\nGenerator.prototype.optional = function (optional) {\n  return 'OPTIONAL ' + this.group(optional);\n};\n\nGenerator.prototype.union = function (union) {\n  return mapJoin(union.patterns, this._newline + 'UNION' + this._newline, function (p) { return this.group(p, true); }, this);\n};\n\nGenerator.prototype.minus = function (minus) {\n  return 'MINUS ' + this.group(minus);\n};\n\nGenerator.prototype.values = function (valuesList) {\n  // Gather unique keys\n  var keys = Object.keys(valuesList.values.reduce(function (keyHash, values) {\n    for (var key in values) keyHash[key] = true;\n    return keyHash;\n  }, {}));\n  // Check whether simple syntax can be used\n  var lparen, rparen;\n  if (keys.length === 1) {\n    lparen = rparen = '';\n  } else {\n    lparen = '(';\n    rparen = ')';\n  }\n  // Create value rows\n  return 'VALUES ' + lparen + keys.join(' ') + rparen + ' {' + this._newline +\n    mapJoin(valuesList.values, this._newline, function (values) {\n      return '  ' + lparen + mapJoin(keys, undefined, function (key) {\n        return values[key] ? this.toEntity(values[key]) : 'UNDEF';\n      }, this) + rparen;\n    }, this) + this._newline + '}';\n};\n\nGenerator.prototype.service = function (service) {\n  return 'SERVICE ' + (service.silent ? 'SILENT ' : '') + this.toEntity(service.name) + ' ' +\n         this.group(service);\n};\n\n// Converts the parsed expression object into a SPARQL expression\nGenerator.prototype.toExpression = function (expr) {\n  if (isTerm(expr)) {\n    return this.toEntity(expr);\n  }\n  switch (expr.type.toLowerCase()) {\n    case 'aggregate':\n      return expr.aggregation.toUpperCase() +\n             '(' + (expr.distinct ? 'DISTINCT ' : '') + this.toExpression(expr.expression) +\n             (typeof expr.separator === 'string' ? '; SEPARATOR = ' + '\"' + expr.separator.replace(escape, escapeReplacer) + '\"' : '') + ')';\n    case 'functioncall':\n      return this.toEntity(expr.function) + '(' + mapJoin(expr.args, ', ', this.toExpression, this) + ')';\n    case 'operation':\n      var operator = expr.operator.toUpperCase(), args = expr.args || [];\n      switch (expr.operator.toLowerCase()) {\n      // Infix operators\n      case '<':\n      case '>':\n      case '>=':\n      case '<=':\n      case '&&':\n      case '||':\n      case '=':\n      case '!=':\n      case '+':\n      case '-':\n      case '*':\n      case '/':\n          return (isTerm(args[0]) ? this.toEntity(args[0]) : '(' + this.toExpression(args[0]) + ')') +\n                 ' ' + operator + ' ' +\n                 (isTerm(args[1]) ? this.toEntity(args[1]) : '(' + this.toExpression(args[1]) + ')');\n      // Unary operators\n      case '!':\n        return '!(' + this.toExpression(args[0]) + ')';\n      case 'uplus':\n        return '+(' + this.toExpression(args[0]) + ')';\n      case 'uminus':\n        return '-(' + this.toExpression(args[0]) + ')';\n      // IN and NOT IN\n      case 'notin':\n        operator = 'NOT IN';\n      case 'in':\n        return this.toExpression(args[0]) + ' ' + operator +\n               '(' + (isString(args[1]) ? args[1] : mapJoin(args[1], ', ', this.toExpression, this)) + ')';\n      // EXISTS and NOT EXISTS\n      case 'notexists':\n        operator = 'NOT EXISTS';\n      case 'exists':\n        return operator + ' ' + this.group(args[0], true);\n      // Other expressions\n      default:\n        return operator + '(' + mapJoin(args, ', ', this.toExpression, this) + ')';\n      }\n    default:\n      throw new Error('Unknown expression type: ' + expr.type);\n  }\n};\n\n// Converts the parsed entity (or property path) into a SPARQL entity\nGenerator.prototype.toEntity = function (value) {\n  if (isTerm(value)) {\n    switch (value.termType) {\n    // variable, * selector, or blank node\n    case 'Wildcard':\n      return '*';\n    case 'Variable':\n      return variableToString(value);\n    case 'BlankNode':\n      return '_:' + value.value;\n    // literal\n    case 'Literal':\n      var lexical = value.value || '', language = value.language || '', datatype = value.datatype;\n      value = '\"' + lexical.replace(escape, escapeReplacer) + '\"';\n      if (language){\n        value += '@' + language;\n      } else if (datatype) {\n        // Abbreviate literals when possible\n        if (!this._explicitDatatype) {\n          switch (datatype.value) {\n          case XSD_STRING:\n            return value;\n          case XSD_INTEGER:\n            if (/^\\d+$/.test(lexical))\n              // Add space to avoid confusion with decimals in broken parsers\n              return lexical + ' ';\n          }\n        }\n        value += '^^' + this.encodeIRI(datatype.value);\n      }\n      return value;\n    case 'Quad':\n      if (!this._sparqlStar)\n          throw new Error('SPARQL* support is not enabled');\n\n      if (value.graph && value.graph.termType !== \"DefaultGraph\") {\n        return '<< GRAPH ' +\n          this.toEntity(value.graph) +\n          ' { ' +\n          this.toEntity(value.subject) + ' ' +\n          this.toEntity(value.predicate) + ' ' +\n          this.toEntity(value.object) +\n          ' } ' +\n          ' >>'\n      }\n      else {\n        return (\n          '<< ' +\n          this.toEntity(value.subject) + ' ' +\n          this.toEntity(value.predicate) + ' ' +\n          this.toEntity(value.object) +\n          ' >>'\n        );\n      }\n    // IRI\n    default:\n      return this.encodeIRI(value.value);\n    }\n  }\n  // property path\n  else {\n    var items = value.items.map(this.toEntity, this), path = value.pathType;\n    switch (path) {\n    // prefix operator\n    case '^':\n    case '!':\n      return path + items[0];\n    // postfix operator\n    case '*':\n    case '+':\n    case '?':\n      return '(' + items[0] + path + ')';\n    // infix operator\n    default:\n      return '(' + items.join(path) + ')';\n    }\n  }\n};\nvar escape = /[\"\\\\\\t\\n\\r\\b\\f]/g,\n    escapeReplacer = function (c) { return escapeReplacements[c]; },\n    escapeReplacements = { '\\\\': '\\\\\\\\', '\"': '\\\\\"', '\\t': '\\\\t',\n                           '\\n': '\\\\n', '\\r': '\\\\r', '\\b': '\\\\b', '\\f': '\\\\f' };\n\n// Represent the IRI, as a prefixed name when possible\nGenerator.prototype.encodeIRI = function (iri) {\n  var prefixMatch = this._prefixRegex.exec(iri);\n  if (prefixMatch) {\n    var prefix = this._prefixByIri[prefixMatch[1]];\n    this._usedPrefixes[prefix] = true;\n    return prefix + ':' + prefixMatch[2];\n  }\n  return '<' + iri + '>';\n};\n\n// Converts the parsed update object into a SPARQL update clause\nGenerator.prototype.toUpdate = function (update) {\n  switch (update.type || update.updateType) {\n  case 'load':\n    return 'LOAD' + (update.source ? ' ' + this.toEntity(update.source) : '') +\n           (update.destination ? ' INTO GRAPH ' + this.toEntity(update.destination) : '');\n  case 'insert':\n    return 'INSERT DATA '  + this.group(update.insert, true);\n  case 'delete':\n    return 'DELETE DATA '  + this.group(update.delete, true);\n  case 'deletewhere':\n    return 'DELETE WHERE ' + this.group(update.delete, true);\n  case 'insertdelete':\n    return (update.graph ? 'WITH ' + this.toEntity(update.graph) + this._newline : '') +\n           (update.delete.length ? 'DELETE ' + this.group(update.delete, true) + this._newline : '') +\n           (update.insert.length ? 'INSERT ' + this.group(update.insert, true) + this._newline : '') +\n           (update.using ? this.graphs('USING ', update.using.default) : '') +\n           (update.using ? this.graphs('USING NAMED ', update.using.named) : '') +\n           'WHERE ' + this.group(update.where, true);\n  case 'add':\n  case 'copy':\n  case 'move':\n    return update.type.toUpperCase()+ ' ' +  (update.silent ? 'SILENT ' : '') + (update.source.default ? 'DEFAULT' : this.toEntity(update.source.name)) +\n           ' TO ' + this.toEntity(update.destination.name);\n  case 'create':\n  case 'clear':\n  case 'drop':\n    return update.type.toUpperCase() + (update.silent ? ' SILENT ' : ' ') + (\n      update.graph.default ? 'DEFAULT' :\n      update.graph.named ? 'NAMED' :\n      update.graph.all ? 'ALL' :\n      ('GRAPH ' + this.toEntity(update.graph.name))\n    );\n  default:\n    throw new Error('Unknown update query type: ' + update.type);\n  }\n};\n\n// Indents each line of the string\nGenerator.prototype.indent = function(text) { return text.replace(/^/gm, this._indent); }\n\nfunction variableToString(variable){\n  return '?' + variable.value;\n}\n\n// Checks whether the object is a string\nfunction isString(object) { return typeof object === 'string'; }\n\n// Checks whether the object is a Term\nfunction isTerm(object) {\n  return typeof object.termType === 'string';\n}\n\n// Checks whether term1 and term2 are equivalent without `.equals()` prototype method\nfunction equalTerms(term1, term2) {\n  if (!term1 || !isTerm(term1)) { return false; }\n  if (!term2 || !isTerm(term2)) { return false; }\n  if (term1.termType !== term2.termType) { return false; }\n  switch (term1.termType) {\n    case 'Literal':\n      return term1.value === term2.value\n          && term1.language === term2.language\n          && equalTerms(term1.datatype, term2.datatype);\n    case 'Quad':\n      return equalTerms(term1.subject, term2.subject)\n          && equalTerms(term1.predicate, term2.predicate)\n          && equalTerms(term1.object, term2.object)\n          && equalTerms(term1.graph, term2.graph);\n    default:\n      return term1.value === term2.value;\n  }\n}\n\n// Maps the array with the given function, and joins the results using the separator\nfunction mapJoin(array, sep, func, self) {\n  return array.map(func, self).join(isString(sep) ? sep : ' ');\n}\n\n/**\n * @param options {\n *   allPrefixes: boolean,\n *   indentation: string,\n *   newline: string\n * }\n */\nmodule.exports = function SparqlGenerator(options = {}) {\n  return {\n    stringify: function (query) {\n      var currentOptions = Object.create(options);\n      currentOptions.prefixes = query.prefixes;\n      return new Generator(currentOptions).toQuery(query);\n    },\n    createGenerator: function() { return new Generator(options); }\n  };\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}