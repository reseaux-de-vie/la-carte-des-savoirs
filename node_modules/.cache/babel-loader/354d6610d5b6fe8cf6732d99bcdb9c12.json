{"ast":null,"code":"import _classCallCheck from \"/home/jean-daniel/Documents/Projets/D\\xE9veloppement/ActivityPods/BCM/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/jean-daniel/Documents/Projets/D\\xE9veloppement/ActivityPods/BCM/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"/home/jean-daniel/Documents/Projets/D\\xE9veloppement/ActivityPods/BCM/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/home/jean-daniel/Documents/Projets/D\\xE9veloppement/ActivityPods/BCM/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport { keydownHandler } from 'prosemirror-keymap';\nimport { Selection, NodeSelection, TextSelection, Plugin } from 'prosemirror-state';\nimport { Slice, Fragment } from 'prosemirror-model';\nimport { DecorationSet, Decoration } from 'prosemirror-view';\n\n/**\nGap cursor selections are represented using this class. Its\n`$anchor` and `$head` properties both point at the cursor position.\n*/\nvar GapCursor = /*#__PURE__*/function (_Selection) {\n  _inherits(GapCursor, _Selection);\n  var _super = _createSuper(GapCursor);\n  /**\n  Create a gap cursor.\n  */\n  function GapCursor($pos) {\n    _classCallCheck(this, GapCursor);\n    return _super.call(this, $pos, $pos);\n  }\n  _createClass(GapCursor, [{\n    key: \"map\",\n    value: function map(doc, mapping) {\n      var $pos = doc.resolve(mapping.map(this.head));\n      return GapCursor.valid($pos) ? new GapCursor($pos) : Selection.near($pos);\n    }\n  }, {\n    key: \"content\",\n    value: function content() {\n      return Slice.empty;\n    }\n  }, {\n    key: \"eq\",\n    value: function eq(other) {\n      return other instanceof GapCursor && other.head == this.head;\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return {\n        type: \"gapcursor\",\n        pos: this.head\n      };\n    }\n    /**\n    @internal\n    */\n  }, {\n    key: \"getBookmark\",\n    value:\n    /**\n    @internal\n    */\n    function getBookmark() {\n      return new GapBookmark(this.anchor);\n    }\n    /**\n    @internal\n    */\n  }], [{\n    key: \"fromJSON\",\n    value: function fromJSON(doc, json) {\n      if (typeof json.pos != \"number\") throw new RangeError(\"Invalid input for GapCursor.fromJSON\");\n      return new GapCursor(doc.resolve(json.pos));\n    }\n  }, {\n    key: \"valid\",\n    value: function valid($pos) {\n      var parent = $pos.parent;\n      if (parent.isTextblock || !closedBefore($pos) || !closedAfter($pos)) return false;\n      var override = parent.type.spec.allowGapCursor;\n      if (override != null) return override;\n      var deflt = parent.contentMatchAt($pos.index()).defaultType;\n      return deflt && deflt.isTextblock;\n    }\n    /**\n    @internal\n    */\n  }, {\n    key: \"findGapCursorFrom\",\n    value: function findGapCursorFrom($pos, dir) {\n      var mustMove = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      search: for (;;) {\n        if (!mustMove && GapCursor.valid($pos)) return $pos;\n        var pos = $pos.pos,\n          next = null;\n        // Scan up from this position\n        for (var d = $pos.depth;; d--) {\n          var parent = $pos.node(d);\n          if (dir > 0 ? $pos.indexAfter(d) < parent.childCount : $pos.index(d) > 0) {\n            next = parent.child(dir > 0 ? $pos.indexAfter(d) : $pos.index(d) - 1);\n            break;\n          } else if (d == 0) {\n            return null;\n          }\n          pos += dir;\n          var $cur = $pos.doc.resolve(pos);\n          if (GapCursor.valid($cur)) return $cur;\n        }\n        // And then down into the next node\n        for (;;) {\n          var inside = dir > 0 ? next.firstChild : next.lastChild;\n          if (!inside) {\n            if (next.isAtom && !next.isText && !NodeSelection.isSelectable(next)) {\n              $pos = $pos.doc.resolve(pos + next.nodeSize * dir);\n              mustMove = false;\n              continue search;\n            }\n            break;\n          }\n          next = inside;\n          pos += dir;\n          var _$cur = $pos.doc.resolve(pos);\n          if (GapCursor.valid(_$cur)) return _$cur;\n        }\n        return null;\n      }\n    }\n  }]);\n  return GapCursor;\n}(Selection);\nGapCursor.prototype.visible = false;\nGapCursor.findFrom = GapCursor.findGapCursorFrom;\nSelection.jsonID(\"gapcursor\", GapCursor);\nvar GapBookmark = /*#__PURE__*/function () {\n  function GapBookmark(pos) {\n    _classCallCheck(this, GapBookmark);\n    this.pos = pos;\n  }\n  _createClass(GapBookmark, [{\n    key: \"map\",\n    value: function map(mapping) {\n      return new GapBookmark(mapping.map(this.pos));\n    }\n  }, {\n    key: \"resolve\",\n    value: function resolve(doc) {\n      var $pos = doc.resolve(this.pos);\n      return GapCursor.valid($pos) ? new GapCursor($pos) : Selection.near($pos);\n    }\n  }]);\n  return GapBookmark;\n}();\nfunction closedBefore($pos) {\n  for (var d = $pos.depth; d >= 0; d--) {\n    var index = $pos.index(d),\n      parent = $pos.node(d);\n    // At the start of this parent, look at next one\n    if (index == 0) {\n      if (parent.type.spec.isolating) return true;\n      continue;\n    }\n    // See if the node before (or its first ancestor) is closed\n    for (var before = parent.child(index - 1);; before = before.lastChild) {\n      if (before.childCount == 0 && !before.inlineContent || before.isAtom || before.type.spec.isolating) return true;\n      if (before.inlineContent) return false;\n    }\n  }\n  // Hit start of document\n  return true;\n}\nfunction closedAfter($pos) {\n  for (var d = $pos.depth; d >= 0; d--) {\n    var index = $pos.indexAfter(d),\n      parent = $pos.node(d);\n    if (index == parent.childCount) {\n      if (parent.type.spec.isolating) return true;\n      continue;\n    }\n    for (var after = parent.child(index);; after = after.firstChild) {\n      if (after.childCount == 0 && !after.inlineContent || after.isAtom || after.type.spec.isolating) return true;\n      if (after.inlineContent) return false;\n    }\n  }\n  return true;\n}\n\n/**\nCreate a gap cursor plugin. When enabled, this will capture clicks\nnear and arrow-key-motion past places that don't have a normally\nselectable position nearby, and create a gap cursor selection for\nthem. The cursor is drawn as an element with class\n`ProseMirror-gapcursor`. You can either include\n`style/gapcursor.css` from the package's directory or add your own\nstyles to make it visible.\n*/\nfunction gapCursor() {\n  return new Plugin({\n    props: {\n      decorations: drawGapCursor,\n      createSelectionBetween: function createSelectionBetween(_view, $anchor, $head) {\n        return $anchor.pos == $head.pos && GapCursor.valid($head) ? new GapCursor($head) : null;\n      },\n      handleClick: handleClick,\n      handleKeyDown: handleKeyDown,\n      handleDOMEvents: {\n        beforeinput: beforeinput\n      }\n    }\n  });\n}\nvar handleKeyDown = keydownHandler({\n  \"ArrowLeft\": arrow(\"horiz\", -1),\n  \"ArrowRight\": arrow(\"horiz\", 1),\n  \"ArrowUp\": arrow(\"vert\", -1),\n  \"ArrowDown\": arrow(\"vert\", 1)\n});\nfunction arrow(axis, dir) {\n  var dirStr = axis == \"vert\" ? dir > 0 ? \"down\" : \"up\" : dir > 0 ? \"right\" : \"left\";\n  return function (state, dispatch, view) {\n    var sel = state.selection;\n    var $start = dir > 0 ? sel.$to : sel.$from,\n      mustMove = sel.empty;\n    if (sel instanceof TextSelection) {\n      if (!view.endOfTextblock(dirStr) || $start.depth == 0) return false;\n      mustMove = false;\n      $start = state.doc.resolve(dir > 0 ? $start.after() : $start.before());\n    }\n    var $found = GapCursor.findGapCursorFrom($start, dir, mustMove);\n    if (!$found) return false;\n    if (dispatch) dispatch(state.tr.setSelection(new GapCursor($found)));\n    return true;\n  };\n}\nfunction handleClick(view, pos, event) {\n  if (!view || !view.editable) return false;\n  var $pos = view.state.doc.resolve(pos);\n  if (!GapCursor.valid($pos)) return false;\n  var clickPos = view.posAtCoords({\n    left: event.clientX,\n    top: event.clientY\n  });\n  if (clickPos && clickPos.inside > -1 && NodeSelection.isSelectable(view.state.doc.nodeAt(clickPos.inside))) return false;\n  view.dispatch(view.state.tr.setSelection(new GapCursor($pos)));\n  return true;\n}\n// This is a hack that, when a composition starts while a gap cursor\n// is active, quickly creates an inline context for the composition to\n// happen in, to avoid it being aborted by the DOM selection being\n// moved into a valid position.\nfunction beforeinput(view, event) {\n  if (event.inputType != \"insertCompositionText\" || !(view.state.selection instanceof GapCursor)) return false;\n  var $from = view.state.selection.$from;\n  var insert = $from.parent.contentMatchAt($from.index()).findWrapping(view.state.schema.nodes.text);\n  if (!insert) return false;\n  var frag = Fragment.empty;\n  for (var i = insert.length - 1; i >= 0; i--) frag = Fragment.from(insert[i].createAndFill(null, frag));\n  var tr = view.state.tr.replace($from.pos, $from.pos, new Slice(frag, 0, 0));\n  tr.setSelection(TextSelection.near(tr.doc.resolve($from.pos + 1)));\n  view.dispatch(tr);\n  return false;\n}\nfunction drawGapCursor(state) {\n  if (!(state.selection instanceof GapCursor)) return null;\n  var node = document.createElement(\"div\");\n  node.className = \"ProseMirror-gapcursor\";\n  return DecorationSet.create(state.doc, [Decoration.widget(state.selection.head, node, {\n    key: \"gapcursor\"\n  })]);\n}\nexport { GapCursor, gapCursor };","map":{"version":3,"names":["keydownHandler","Selection","NodeSelection","TextSelection","Plugin","Slice","Fragment","DecorationSet","Decoration","GapCursor","$pos","doc","mapping","resolve","map","head","valid","near","empty","other","type","pos","GapBookmark","anchor","json","RangeError","parent","isTextblock","closedBefore","closedAfter","override","spec","allowGapCursor","deflt","contentMatchAt","index","defaultType","dir","mustMove","search","next","d","depth","node","indexAfter","childCount","child","$cur","inside","firstChild","lastChild","isAtom","isText","isSelectable","nodeSize","prototype","visible","findFrom","findGapCursorFrom","jsonID","isolating","before","inlineContent","after","gapCursor","props","decorations","drawGapCursor","createSelectionBetween","_view","$anchor","$head","handleClick","handleKeyDown","handleDOMEvents","beforeinput","arrow","axis","dirStr","state","dispatch","view","sel","selection","$start","$to","$from","endOfTextblock","$found","tr","setSelection","event","editable","clickPos","posAtCoords","left","clientX","top","clientY","nodeAt","inputType","insert","findWrapping","schema","nodes","text","frag","i","length","from","createAndFill","replace","document","createElement","className","create","widget","key"],"sources":["/home/jean-daniel/Documents/Projets/DÃ©veloppement/ActivityPods/BCM/frontend/node_modules/prosemirror-gapcursor/dist/index.js"],"sourcesContent":["import { keydownHandler } from 'prosemirror-keymap';\nimport { Selection, NodeSelection, TextSelection, Plugin } from 'prosemirror-state';\nimport { Slice, Fragment } from 'prosemirror-model';\nimport { DecorationSet, Decoration } from 'prosemirror-view';\n\n/**\nGap cursor selections are represented using this class. Its\n`$anchor` and `$head` properties both point at the cursor position.\n*/\nclass GapCursor extends Selection {\n    /**\n    Create a gap cursor.\n    */\n    constructor($pos) {\n        super($pos, $pos);\n    }\n    map(doc, mapping) {\n        let $pos = doc.resolve(mapping.map(this.head));\n        return GapCursor.valid($pos) ? new GapCursor($pos) : Selection.near($pos);\n    }\n    content() { return Slice.empty; }\n    eq(other) {\n        return other instanceof GapCursor && other.head == this.head;\n    }\n    toJSON() {\n        return { type: \"gapcursor\", pos: this.head };\n    }\n    /**\n    @internal\n    */\n    static fromJSON(doc, json) {\n        if (typeof json.pos != \"number\")\n            throw new RangeError(\"Invalid input for GapCursor.fromJSON\");\n        return new GapCursor(doc.resolve(json.pos));\n    }\n    /**\n    @internal\n    */\n    getBookmark() { return new GapBookmark(this.anchor); }\n    /**\n    @internal\n    */\n    static valid($pos) {\n        let parent = $pos.parent;\n        if (parent.isTextblock || !closedBefore($pos) || !closedAfter($pos))\n            return false;\n        let override = parent.type.spec.allowGapCursor;\n        if (override != null)\n            return override;\n        let deflt = parent.contentMatchAt($pos.index()).defaultType;\n        return deflt && deflt.isTextblock;\n    }\n    /**\n    @internal\n    */\n    static findGapCursorFrom($pos, dir, mustMove = false) {\n        search: for (;;) {\n            if (!mustMove && GapCursor.valid($pos))\n                return $pos;\n            let pos = $pos.pos, next = null;\n            // Scan up from this position\n            for (let d = $pos.depth;; d--) {\n                let parent = $pos.node(d);\n                if (dir > 0 ? $pos.indexAfter(d) < parent.childCount : $pos.index(d) > 0) {\n                    next = parent.child(dir > 0 ? $pos.indexAfter(d) : $pos.index(d) - 1);\n                    break;\n                }\n                else if (d == 0) {\n                    return null;\n                }\n                pos += dir;\n                let $cur = $pos.doc.resolve(pos);\n                if (GapCursor.valid($cur))\n                    return $cur;\n            }\n            // And then down into the next node\n            for (;;) {\n                let inside = dir > 0 ? next.firstChild : next.lastChild;\n                if (!inside) {\n                    if (next.isAtom && !next.isText && !NodeSelection.isSelectable(next)) {\n                        $pos = $pos.doc.resolve(pos + next.nodeSize * dir);\n                        mustMove = false;\n                        continue search;\n                    }\n                    break;\n                }\n                next = inside;\n                pos += dir;\n                let $cur = $pos.doc.resolve(pos);\n                if (GapCursor.valid($cur))\n                    return $cur;\n            }\n            return null;\n        }\n    }\n}\nGapCursor.prototype.visible = false;\nGapCursor.findFrom = GapCursor.findGapCursorFrom;\nSelection.jsonID(\"gapcursor\", GapCursor);\nclass GapBookmark {\n    constructor(pos) {\n        this.pos = pos;\n    }\n    map(mapping) {\n        return new GapBookmark(mapping.map(this.pos));\n    }\n    resolve(doc) {\n        let $pos = doc.resolve(this.pos);\n        return GapCursor.valid($pos) ? new GapCursor($pos) : Selection.near($pos);\n    }\n}\nfunction closedBefore($pos) {\n    for (let d = $pos.depth; d >= 0; d--) {\n        let index = $pos.index(d), parent = $pos.node(d);\n        // At the start of this parent, look at next one\n        if (index == 0) {\n            if (parent.type.spec.isolating)\n                return true;\n            continue;\n        }\n        // See if the node before (or its first ancestor) is closed\n        for (let before = parent.child(index - 1);; before = before.lastChild) {\n            if ((before.childCount == 0 && !before.inlineContent) || before.isAtom || before.type.spec.isolating)\n                return true;\n            if (before.inlineContent)\n                return false;\n        }\n    }\n    // Hit start of document\n    return true;\n}\nfunction closedAfter($pos) {\n    for (let d = $pos.depth; d >= 0; d--) {\n        let index = $pos.indexAfter(d), parent = $pos.node(d);\n        if (index == parent.childCount) {\n            if (parent.type.spec.isolating)\n                return true;\n            continue;\n        }\n        for (let after = parent.child(index);; after = after.firstChild) {\n            if ((after.childCount == 0 && !after.inlineContent) || after.isAtom || after.type.spec.isolating)\n                return true;\n            if (after.inlineContent)\n                return false;\n        }\n    }\n    return true;\n}\n\n/**\nCreate a gap cursor plugin. When enabled, this will capture clicks\nnear and arrow-key-motion past places that don't have a normally\nselectable position nearby, and create a gap cursor selection for\nthem. The cursor is drawn as an element with class\n`ProseMirror-gapcursor`. You can either include\n`style/gapcursor.css` from the package's directory or add your own\nstyles to make it visible.\n*/\nfunction gapCursor() {\n    return new Plugin({\n        props: {\n            decorations: drawGapCursor,\n            createSelectionBetween(_view, $anchor, $head) {\n                return $anchor.pos == $head.pos && GapCursor.valid($head) ? new GapCursor($head) : null;\n            },\n            handleClick,\n            handleKeyDown,\n            handleDOMEvents: { beforeinput: beforeinput }\n        }\n    });\n}\nconst handleKeyDown = keydownHandler({\n    \"ArrowLeft\": arrow(\"horiz\", -1),\n    \"ArrowRight\": arrow(\"horiz\", 1),\n    \"ArrowUp\": arrow(\"vert\", -1),\n    \"ArrowDown\": arrow(\"vert\", 1)\n});\nfunction arrow(axis, dir) {\n    const dirStr = axis == \"vert\" ? (dir > 0 ? \"down\" : \"up\") : (dir > 0 ? \"right\" : \"left\");\n    return function (state, dispatch, view) {\n        let sel = state.selection;\n        let $start = dir > 0 ? sel.$to : sel.$from, mustMove = sel.empty;\n        if (sel instanceof TextSelection) {\n            if (!view.endOfTextblock(dirStr) || $start.depth == 0)\n                return false;\n            mustMove = false;\n            $start = state.doc.resolve(dir > 0 ? $start.after() : $start.before());\n        }\n        let $found = GapCursor.findGapCursorFrom($start, dir, mustMove);\n        if (!$found)\n            return false;\n        if (dispatch)\n            dispatch(state.tr.setSelection(new GapCursor($found)));\n        return true;\n    };\n}\nfunction handleClick(view, pos, event) {\n    if (!view || !view.editable)\n        return false;\n    let $pos = view.state.doc.resolve(pos);\n    if (!GapCursor.valid($pos))\n        return false;\n    let clickPos = view.posAtCoords({ left: event.clientX, top: event.clientY });\n    if (clickPos && clickPos.inside > -1 && NodeSelection.isSelectable(view.state.doc.nodeAt(clickPos.inside)))\n        return false;\n    view.dispatch(view.state.tr.setSelection(new GapCursor($pos)));\n    return true;\n}\n// This is a hack that, when a composition starts while a gap cursor\n// is active, quickly creates an inline context for the composition to\n// happen in, to avoid it being aborted by the DOM selection being\n// moved into a valid position.\nfunction beforeinput(view, event) {\n    if (event.inputType != \"insertCompositionText\" || !(view.state.selection instanceof GapCursor))\n        return false;\n    let { $from } = view.state.selection;\n    let insert = $from.parent.contentMatchAt($from.index()).findWrapping(view.state.schema.nodes.text);\n    if (!insert)\n        return false;\n    let frag = Fragment.empty;\n    for (let i = insert.length - 1; i >= 0; i--)\n        frag = Fragment.from(insert[i].createAndFill(null, frag));\n    let tr = view.state.tr.replace($from.pos, $from.pos, new Slice(frag, 0, 0));\n    tr.setSelection(TextSelection.near(tr.doc.resolve($from.pos + 1)));\n    view.dispatch(tr);\n    return false;\n}\nfunction drawGapCursor(state) {\n    if (!(state.selection instanceof GapCursor))\n        return null;\n    let node = document.createElement(\"div\");\n    node.className = \"ProseMirror-gapcursor\";\n    return DecorationSet.create(state.doc, [Decoration.widget(state.selection.head, node, { key: \"gapcursor\" })]);\n}\n\nexport { GapCursor, gapCursor };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}