{"ast":null,"code":"import _objectSpread from \"/home/jean-daniel/Documents/Projets/D\\xE9veloppement/ActivityPods/BCM/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";\nimport _toConsumableArray from \"/home/jean-daniel/Documents/Projets/D\\xE9veloppement/ActivityPods/BCM/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport { combineTransactionSteps, getChangedRanges, getMarksBetween, findChildrenInRange, getAttributes, Mark, mergeAttributes, markPasteRule } from '@tiptap/core';\nimport { test, find as _find, registerCustomProtocol, reset } from 'linkifyjs';\nimport { Plugin, PluginKey } from 'prosemirror-state';\nfunction autolink(options) {\n  return new Plugin({\n    key: new PluginKey('autolink'),\n    appendTransaction: function appendTransaction(transactions, oldState, newState) {\n      var docChanges = transactions.some(function (transaction) {\n        return transaction.docChanged;\n      }) && !oldState.doc.eq(newState.doc);\n      var preventAutolink = transactions.some(function (transaction) {\n        return transaction.getMeta('preventAutolink');\n      });\n      if (!docChanges || preventAutolink) {\n        return;\n      }\n      var tr = newState.tr;\n      var transform = combineTransactionSteps(oldState.doc, _toConsumableArray(transactions));\n      var mapping = transform.mapping;\n      var changes = getChangedRanges(transform);\n      changes.forEach(function (_ref) {\n        var oldRange = _ref.oldRange,\n          newRange = _ref.newRange;\n        // at first we check if we have to remove links\n        getMarksBetween(oldRange.from, oldRange.to, oldState.doc).filter(function (item) {\n          return item.mark.type === options.type;\n        }).forEach(function (oldMark) {\n          var newFrom = mapping.map(oldMark.from);\n          var newTo = mapping.map(oldMark.to);\n          var newMarks = getMarksBetween(newFrom, newTo, newState.doc).filter(function (item) {\n            return item.mark.type === options.type;\n          });\n          if (!newMarks.length) {\n            return;\n          }\n          var newMark = newMarks[0];\n          var oldLinkText = oldState.doc.textBetween(oldMark.from, oldMark.to, undefined, ' ');\n          var newLinkText = newState.doc.textBetween(newMark.from, newMark.to, undefined, ' ');\n          var wasLink = test(oldLinkText);\n          var isLink = test(newLinkText);\n          // remove only the link, if it was a link before too\n          // because we don’t want to remove links that were set manually\n          if (wasLink && !isLink) {\n            tr.removeMark(newMark.from, newMark.to, options.type);\n          }\n        });\n        // now let’s see if we can add new links\n        var nodesInChangedRanges = findChildrenInRange(newState.doc, newRange, function (node) {\n          return node.isTextblock;\n        });\n        var textBlock;\n        var textBeforeWhitespace;\n        if (nodesInChangedRanges.length > 1) {\n          // Grab the first node within the changed ranges (ex. the first of two paragraphs when hitting enter)\n          textBlock = nodesInChangedRanges[0];\n          textBeforeWhitespace = newState.doc.textBetween(textBlock.pos, textBlock.pos + textBlock.node.nodeSize, undefined, ' ');\n        } else if (nodesInChangedRanges.length\n        // We want to make sure to include the block seperator argument to treat hard breaks like spaces\n        && newState.doc.textBetween(newRange.from, newRange.to, ' ', ' ').endsWith(' ')) {\n          textBlock = nodesInChangedRanges[0];\n          textBeforeWhitespace = newState.doc.textBetween(textBlock.pos, newRange.to, undefined, ' ');\n        }\n        if (textBlock && textBeforeWhitespace) {\n          var wordsBeforeWhitespace = textBeforeWhitespace.split(' ').filter(function (s) {\n            return s !== '';\n          });\n          if (wordsBeforeWhitespace.length <= 0) {\n            return false;\n          }\n          var lastWordBeforeSpace = wordsBeforeWhitespace[wordsBeforeWhitespace.length - 1];\n          var lastWordAndBlockOffset = textBlock.pos + textBeforeWhitespace.lastIndexOf(lastWordBeforeSpace);\n          if (!lastWordBeforeSpace) {\n            return false;\n          }\n          _find(lastWordBeforeSpace).filter(function (link) {\n            return link.isLink;\n          }).filter(function (link) {\n            if (options.validate) {\n              return options.validate(link.value);\n            }\n            return true;\n          })\n          // calculate link position\n          .map(function (link) {\n            return _objectSpread(_objectSpread({}, link), {}, {\n              from: lastWordAndBlockOffset + link.start + 1,\n              to: lastWordAndBlockOffset + link.end + 1\n            });\n          })\n          // add link mark\n          .forEach(function (link) {\n            tr.addMark(link.from, link.to, options.type.create({\n              href: link.href\n            }));\n          });\n        }\n      });\n      if (!tr.steps.length) {\n        return;\n      }\n      return tr;\n    }\n  });\n}\nfunction clickHandler(options) {\n  return new Plugin({\n    key: new PluginKey('handleClickLink'),\n    props: {\n      handleClick: function handleClick(view, pos, event) {\n        var _a;\n        var attrs = getAttributes(view.state, options.type.name);\n        var link = (_a = event.target) === null || _a === void 0 ? void 0 : _a.closest('a');\n        if (link && attrs.href) {\n          window.open(attrs.href, attrs.target);\n          return true;\n        }\n        return false;\n      }\n    }\n  });\n}\nfunction pasteHandler(options) {\n  return new Plugin({\n    key: new PluginKey('handlePasteLink'),\n    props: {\n      handlePaste: function handlePaste(view, event, slice) {\n        var state = view.state;\n        var selection = state.selection;\n        var empty = selection.empty;\n        if (empty) {\n          return false;\n        }\n        var textContent = '';\n        slice.content.forEach(function (node) {\n          textContent += node.textContent;\n        });\n        var link = _find(textContent).find(function (item) {\n          return item.isLink && item.value === textContent;\n        });\n        if (!textContent || !link) {\n          return false;\n        }\n        options.editor.commands.setMark(options.type, {\n          href: link.href\n        });\n        return true;\n      }\n    }\n  });\n}\nvar Link = Mark.create({\n  name: 'link',\n  priority: 1000,\n  keepOnSplit: false,\n  onCreate: function onCreate() {\n    this.options.protocols.forEach(registerCustomProtocol);\n  },\n  onDestroy: function onDestroy() {\n    reset();\n  },\n  inclusive: function inclusive() {\n    return this.options.autolink;\n  },\n  addOptions: function addOptions() {\n    return {\n      openOnClick: true,\n      linkOnPaste: true,\n      autolink: true,\n      protocols: [],\n      HTMLAttributes: {\n        target: '_blank',\n        rel: 'noopener noreferrer nofollow',\n        class: null\n      },\n      validate: undefined\n    };\n  },\n  addAttributes: function addAttributes() {\n    return {\n      href: {\n        default: null\n      },\n      target: {\n        default: this.options.HTMLAttributes.target\n      },\n      class: {\n        default: this.options.HTMLAttributes.class\n      }\n    };\n  },\n  parseHTML: function parseHTML() {\n    return [{\n      tag: 'a[href]:not([href *= \"javascript:\" i])'\n    }];\n  },\n  renderHTML: function renderHTML(_ref2) {\n    var HTMLAttributes = _ref2.HTMLAttributes;\n    return ['a', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];\n  },\n  addCommands: function addCommands() {\n    var _this = this;\n    return {\n      setLink: function setLink(attributes) {\n        return function (_ref3) {\n          var chain = _ref3.chain;\n          return chain().setMark(_this.name, attributes).setMeta('preventAutolink', true).run();\n        };\n      },\n      toggleLink: function toggleLink(attributes) {\n        return function (_ref4) {\n          var chain = _ref4.chain;\n          return chain().toggleMark(_this.name, attributes, {\n            extendEmptyMarkRange: true\n          }).setMeta('preventAutolink', true).run();\n        };\n      },\n      unsetLink: function unsetLink() {\n        return function (_ref5) {\n          var chain = _ref5.chain;\n          return chain().unsetMark(_this.name, {\n            extendEmptyMarkRange: true\n          }).setMeta('preventAutolink', true).run();\n        };\n      }\n    };\n  },\n  addPasteRules: function addPasteRules() {\n    var _this2 = this;\n    return [markPasteRule({\n      find: function find(text) {\n        return _find(text).filter(function (link) {\n          if (_this2.options.validate) {\n            return _this2.options.validate(link.value);\n          }\n          return true;\n        }).filter(function (link) {\n          return link.isLink;\n        }).map(function (link) {\n          return {\n            text: link.value,\n            index: link.start,\n            data: link\n          };\n        });\n      },\n      type: this.type,\n      getAttributes: function getAttributes(match) {\n        var _a;\n        return {\n          href: (_a = match.data) === null || _a === void 0 ? void 0 : _a.href\n        };\n      }\n    })];\n  },\n  addProseMirrorPlugins: function addProseMirrorPlugins() {\n    var plugins = [];\n    if (this.options.autolink) {\n      plugins.push(autolink({\n        type: this.type,\n        validate: this.options.validate\n      }));\n    }\n    if (this.options.openOnClick) {\n      plugins.push(clickHandler({\n        type: this.type\n      }));\n    }\n    if (this.options.linkOnPaste) {\n      plugins.push(pasteHandler({\n        editor: this.editor,\n        type: this.type\n      }));\n    }\n    return plugins;\n  }\n});\nexport { Link, Link as default };","map":{"version":3,"sources":["../src/helpers/autolink.ts","../src/helpers/clickHandler.ts","../src/helpers/pasteHandler.ts","../src/link.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  combineTransactionSteps,\n  findChildrenInRange,\n  getChangedRanges,\n  getMarksBetween,\n  NodeWithPos,\n} from '@tiptap/core'\nimport { find, test } from 'linkifyjs'\nimport { MarkType } from 'prosemirror-model'\nimport { Plugin, PluginKey } from 'prosemirror-state'\n\ntype AutolinkOptions = {\n  type: MarkType,\n  validate?: (url: string) => boolean,\n}\n\nexport function autolink(options: AutolinkOptions): Plugin {\n  return new Plugin({\n    key: new PluginKey('autolink'),\n    appendTransaction: (transactions, oldState, newState) => {\n      const docChanges = transactions.some(transaction => transaction.docChanged)\n        && !oldState.doc.eq(newState.doc)\n      const preventAutolink = transactions.some(transaction => transaction.getMeta('preventAutolink'))\n\n      if (!docChanges || preventAutolink) {\n        return\n      }\n\n      const { tr } = newState\n      const transform = combineTransactionSteps(oldState.doc, [...transactions])\n      const { mapping } = transform\n      const changes = getChangedRanges(transform)\n\n      changes.forEach(({ oldRange, newRange }) => {\n        // at first we check if we have to remove links\n        getMarksBetween(oldRange.from, oldRange.to, oldState.doc)\n          .filter(item => item.mark.type === options.type)\n          .forEach(oldMark => {\n            const newFrom = mapping.map(oldMark.from)\n            const newTo = mapping.map(oldMark.to)\n            const newMarks = getMarksBetween(newFrom, newTo, newState.doc)\n              .filter(item => item.mark.type === options.type)\n\n            if (!newMarks.length) {\n              return\n            }\n\n            const newMark = newMarks[0]\n            const oldLinkText = oldState.doc.textBetween(oldMark.from, oldMark.to, undefined, ' ')\n            const newLinkText = newState.doc.textBetween(newMark.from, newMark.to, undefined, ' ')\n            const wasLink = test(oldLinkText)\n            const isLink = test(newLinkText)\n\n            // remove only the link, if it was a link before too\n            // because we don’t want to remove links that were set manually\n            if (wasLink && !isLink) {\n              tr.removeMark(newMark.from, newMark.to, options.type)\n            }\n          })\n\n        // now let’s see if we can add new links\n        const nodesInChangedRanges = findChildrenInRange(newState.doc, newRange, node => node.isTextblock)\n\n        let textBlock: NodeWithPos | undefined\n        let textBeforeWhitespace: string | undefined\n\n        if (nodesInChangedRanges.length > 1) {\n          // Grab the first node within the changed ranges (ex. the first of two paragraphs when hitting enter)\n          textBlock = nodesInChangedRanges[0]\n          textBeforeWhitespace = newState.doc.textBetween(\n            textBlock.pos,\n            textBlock.pos + textBlock.node.nodeSize,\n            undefined,\n            ' ',\n          )\n        } else if (\n          nodesInChangedRanges.length\n          // We want to make sure to include the block seperator argument to treat hard breaks like spaces\n          && newState.doc.textBetween(newRange.from, newRange.to, ' ', ' ').endsWith(' ')\n        ) {\n          textBlock = nodesInChangedRanges[0]\n          textBeforeWhitespace = newState.doc.textBetween(\n            textBlock.pos,\n            newRange.to,\n            undefined,\n            ' ',\n          )\n        }\n\n        if (textBlock && textBeforeWhitespace) {\n          const wordsBeforeWhitespace = textBeforeWhitespace.split(' ').filter(s => s !== '')\n\n          if (wordsBeforeWhitespace.length <= 0) {\n            return false\n          }\n\n          const lastWordBeforeSpace = wordsBeforeWhitespace[wordsBeforeWhitespace.length - 1]\n          const lastWordAndBlockOffset = textBlock.pos + textBeforeWhitespace.lastIndexOf(lastWordBeforeSpace)\n\n          if (!lastWordBeforeSpace) {\n            return false\n          }\n\n          find(lastWordBeforeSpace)\n            .filter(link => link.isLink)\n            .filter(link => {\n              if (options.validate) {\n                return options.validate(link.value)\n              }\n              return true\n            })\n            // calculate link position\n            .map(link => ({\n              ...link,\n              from: lastWordAndBlockOffset + link.start + 1,\n              to: lastWordAndBlockOffset + link.end + 1,\n            }))\n            // add link mark\n            .forEach(link => {\n              tr.addMark(link.from, link.to, options.type.create({\n                href: link.href,\n              }))\n            })\n        }\n      })\n\n      if (!tr.steps.length) {\n        return\n      }\n\n      return tr\n    },\n  })\n}\n","import { getAttributes } from '@tiptap/core'\nimport { MarkType } from 'prosemirror-model'\nimport { Plugin, PluginKey } from 'prosemirror-state'\n\ntype ClickHandlerOptions = {\n  type: MarkType,\n}\n\nexport function clickHandler(options: ClickHandlerOptions): Plugin {\n  return new Plugin({\n    key: new PluginKey('handleClickLink'),\n    props: {\n      handleClick: (view, pos, event) => {\n        const attrs = getAttributes(view.state, options.type.name)\n        const link = (event.target as HTMLElement)?.closest('a')\n\n        if (link && attrs.href) {\n          window.open(attrs.href, attrs.target)\n\n          return true\n        }\n\n        return false\n      },\n    },\n  })\n}\n","import { Editor } from '@tiptap/core'\nimport { find } from 'linkifyjs'\nimport { MarkType } from 'prosemirror-model'\nimport { Plugin, PluginKey } from 'prosemirror-state'\n\ntype PasteHandlerOptions = {\n  editor: Editor,\n  type: MarkType,\n}\n\nexport function pasteHandler(options: PasteHandlerOptions): Plugin {\n  return new Plugin({\n    key: new PluginKey('handlePasteLink'),\n    props: {\n      handlePaste: (view, event, slice) => {\n        const { state } = view\n        const { selection } = state\n        const { empty } = selection\n\n        if (empty) {\n          return false\n        }\n\n        let textContent = ''\n\n        slice.content.forEach(node => {\n          textContent += node.textContent\n        })\n\n        const link = find(textContent).find(item => item.isLink && item.value === textContent)\n\n        if (!textContent || !link) {\n          return false\n        }\n\n        options.editor.commands.setMark(options.type, {\n          href: link.href,\n        })\n\n        return true\n      },\n    },\n  })\n}\n","import { Mark, markPasteRule, mergeAttributes } from '@tiptap/core'\nimport { find, registerCustomProtocol, reset } from 'linkifyjs'\nimport { Plugin } from 'prosemirror-state'\n\nimport { autolink } from './helpers/autolink'\nimport { clickHandler } from './helpers/clickHandler'\nimport { pasteHandler } from './helpers/pasteHandler'\n\nexport interface LinkOptions {\n  /**\n   * If enabled, it adds links as you type.\n   */\n  autolink: boolean,\n  /**\n   * An array of custom protocols to be registered with linkifyjs.\n   */\n  protocols: Array<string>,\n  /**\n   * If enabled, links will be opened on click.\n   */\n  openOnClick: boolean,\n  /**\n   * Adds a link to the current selection if the pasted content only contains an url.\n   */\n  linkOnPaste: boolean,\n  /**\n   * A list of HTML attributes to be rendered.\n   */\n  HTMLAttributes: Record<string, any>,\n  /**\n   * A validation function that modifies link verification for the auto linker.\n   * @param url - The url to be validated.\n   * @returns - True if the url is valid, false otherwise.\n   */\n  validate?: (url: string) => boolean,\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    link: {\n      /**\n       * Set a link mark\n       */\n      setLink: (attributes: { href: string, target?: string | null }) => ReturnType,\n      /**\n       * Toggle a link mark\n       */\n      toggleLink: (attributes: { href: string, target?: string | null }) => ReturnType,\n      /**\n       * Unset a link mark\n       */\n      unsetLink: () => ReturnType,\n    }\n  }\n}\n\nexport const Link = Mark.create<LinkOptions>({\n  name: 'link',\n\n  priority: 1000,\n\n  keepOnSplit: false,\n\n  onCreate() {\n    this.options.protocols.forEach(registerCustomProtocol)\n  },\n\n  onDestroy() {\n    reset()\n  },\n\n  inclusive() {\n    return this.options.autolink\n  },\n\n  addOptions() {\n    return {\n      openOnClick: true,\n      linkOnPaste: true,\n      autolink: true,\n      protocols: [],\n      HTMLAttributes: {\n        target: '_blank',\n        rel: 'noopener noreferrer nofollow',\n        class: null,\n      },\n      validate: undefined,\n    }\n  },\n\n  addAttributes() {\n    return {\n      href: {\n        default: null,\n      },\n      target: {\n        default: this.options.HTMLAttributes.target,\n      },\n      class: {\n        default: this.options.HTMLAttributes.class,\n      },\n    }\n  },\n\n  parseHTML() {\n    return [\n      { tag: 'a[href]:not([href *= \"javascript:\" i])' },\n    ]\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return [\n      'a',\n      mergeAttributes(this.options.HTMLAttributes, HTMLAttributes),\n      0,\n    ]\n  },\n\n  addCommands() {\n    return {\n      setLink: attributes => ({ chain }) => {\n        return chain()\n          .setMark(this.name, attributes)\n          .setMeta('preventAutolink', true)\n          .run()\n      },\n\n      toggleLink: attributes => ({ chain }) => {\n        return chain()\n          .toggleMark(this.name, attributes, { extendEmptyMarkRange: true })\n          .setMeta('preventAutolink', true)\n          .run()\n      },\n\n      unsetLink: () => ({ chain }) => {\n        return chain()\n          .unsetMark(this.name, { extendEmptyMarkRange: true })\n          .setMeta('preventAutolink', true)\n          .run()\n      },\n    }\n  },\n\n  addPasteRules() {\n    return [\n      markPasteRule({\n        find: text => find(text)\n          .filter(link => {\n            if (this.options.validate) {\n              return this.options.validate(link.value)\n            }\n\n            return true\n          })\n          .filter(link => link.isLink)\n          .map(link => ({\n            text: link.value,\n            index: link.start,\n            data: link,\n          })),\n        type: this.type,\n        getAttributes: match => ({\n          href: match.data?.href,\n        }),\n      }),\n    ]\n  },\n\n  addProseMirrorPlugins() {\n    const plugins: Plugin[] = []\n\n    if (this.options.autolink) {\n      plugins.push(autolink({\n        type: this.type,\n        validate: this.options.validate,\n      }))\n    }\n\n    if (this.options.openOnClick) {\n      plugins.push(clickHandler({\n        type: this.type,\n      }))\n    }\n\n    if (this.options.linkOnPaste) {\n      plugins.push(pasteHandler({\n        editor: this.editor,\n        type: this.type,\n      }))\n    }\n\n    return plugins\n  },\n})\n"]},"metadata":{},"sourceType":"module"}