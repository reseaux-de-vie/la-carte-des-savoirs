{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/home/jean-daniel/Documents/Projets/D\\xE9veloppement/ActivityPods/BCM/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\nvar _createClass = require(\"/home/jean-daniel/Documents/Projets/D\\xE9veloppement/ActivityPods/BCM/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DataFactory = void 0;\nvar BlankNode_1 = require(\"./BlankNode\");\nvar DefaultGraph_1 = require(\"./DefaultGraph\");\nvar Literal_1 = require(\"./Literal\");\nvar NamedNode_1 = require(\"./NamedNode\");\nvar Quad_1 = require(\"./Quad\");\nvar Variable_1 = require(\"./Variable\");\nvar dataFactoryCounter = 0;\n/**\n * A factory for instantiating RDF terms and quads.\n */\nvar DataFactory = /*#__PURE__*/function () {\n  function DataFactory(options) {\n    _classCallCheck(this, DataFactory);\n    this.blankNodeCounter = 0;\n    options = options || {};\n    this.blankNodePrefix = options.blankNodePrefix || \"df_\".concat(dataFactoryCounter++, \"_\");\n  }\n  /**\n   * @param value The IRI for the named node.\n   * @return A new instance of NamedNode.\n   * @see NamedNode\n   */\n  _createClass(DataFactory, [{\n    key: \"namedNode\",\n    value: function namedNode(value) {\n      return new NamedNode_1.NamedNode(value);\n    }\n    /**\n     * @param value The optional blank node identifier.\n     * @return A new instance of BlankNode.\n     *         If the `value` parameter is undefined a new identifier\n     *         for the blank node is generated for each call.\n     * @see BlankNode\n     */\n  }, {\n    key: \"blankNode\",\n    value: function blankNode(value) {\n      return new BlankNode_1.BlankNode(value || \"\".concat(this.blankNodePrefix).concat(this.blankNodeCounter++));\n    }\n    /**\n     * @param value              The literal value.\n     * @param languageOrDatatype The optional language or datatype.\n     *                           If `languageOrDatatype` is a NamedNode,\n     *                           then it is used for the value of `NamedNode.datatype`.\n     *                           Otherwise `languageOrDatatype` is used for the value\n     *                           of `NamedNode.language`.\n     * @return A new instance of Literal.\n     * @see Literal\n     */\n  }, {\n    key: \"literal\",\n    value: function literal(value, languageOrDatatype) {\n      return new Literal_1.Literal(value, languageOrDatatype);\n    }\n    /**\n     * This method is optional.\n     * @param value The variable name\n     * @return A new instance of Variable.\n     * @see Variable\n     */\n  }, {\n    key: \"variable\",\n    value: function variable(value) {\n      return new Variable_1.Variable(value);\n    }\n    /**\n     * @return An instance of DefaultGraph.\n     */\n  }, {\n    key: \"defaultGraph\",\n    value: function defaultGraph() {\n      return DefaultGraph_1.DefaultGraph.INSTANCE;\n    }\n    /**\n     * @param subject   The quad subject term.\n     * @param predicate The quad predicate term.\n     * @param object    The quad object term.\n     * @param graph     The quad graph term.\n     * @return A new instance of Quad.\n     * @see Quad\n     */\n  }, {\n    key: \"quad\",\n    value: function quad(subject, predicate, object, graph) {\n      return new Quad_1.Quad(subject, predicate, object, graph || this.defaultGraph());\n    }\n    /**\n     * Create a deep copy of the given term using this data factory.\n     * @param original An RDF term.\n     * @return A deep copy of the given term.\n     */\n  }, {\n    key: \"fromTerm\",\n    value: function fromTerm(original) {\n      // TODO: remove nasty any casts when this TS bug has been fixed:\n      //  https://github.com/microsoft/TypeScript/issues/26933\n      switch (original.termType) {\n        case 'NamedNode':\n          return this.namedNode(original.value);\n        case 'BlankNode':\n          return this.blankNode(original.value);\n        case 'Literal':\n          if (original.language) {\n            return this.literal(original.value, original.language);\n          }\n          if (!original.datatype.equals(Literal_1.Literal.XSD_STRING)) {\n            return this.literal(original.value, this.fromTerm(original.datatype));\n          }\n          return this.literal(original.value);\n        case 'Variable':\n          return this.variable(original.value);\n        case 'DefaultGraph':\n          return this.defaultGraph();\n        case 'Quad':\n          return this.quad(this.fromTerm(original.subject), this.fromTerm(original.predicate), this.fromTerm(original.object), this.fromTerm(original.graph));\n      }\n    }\n    /**\n     * Create a deep copy of the given quad using this data factory.\n     * @param original An RDF quad.\n     * @return A deep copy of the given quad.\n     */\n  }, {\n    key: \"fromQuad\",\n    value: function fromQuad(original) {\n      return this.fromTerm(original);\n    }\n    /**\n     * Reset the internal blank node counter.\n     */\n  }, {\n    key: \"resetBlankNodeCounter\",\n    value: function resetBlankNodeCounter() {\n      this.blankNodeCounter = 0;\n    }\n  }]);\n  return DataFactory;\n}();\nexports.DataFactory = DataFactory;","map":{"version":3,"sources":["DataFactory.ts"],"names":[],"mappings":"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","sourcesContent":["import type * as RDF from '@rdfjs/types';\nimport { BlankNode } from './BlankNode';\nimport { DefaultGraph } from './DefaultGraph';\nimport { Literal } from './Literal';\nimport { NamedNode } from './NamedNode';\nimport { Quad } from './Quad';\nimport { Variable } from './Variable';\n\nlet dataFactoryCounter = 0;\n\n/**\n * A factory for instantiating RDF terms and quads.\n */\nexport class DataFactory<Q extends RDF.BaseQuad = RDF.Quad> implements RDF.DataFactory<Q> {\n  private readonly blankNodePrefix: string;\n  private blankNodeCounter = 0;\n\n  public constructor(options?: IDataFactoryOptions) {\n    options = options || {};\n    this.blankNodePrefix = options.blankNodePrefix || `df_${dataFactoryCounter++}_`;\n  }\n\n  /**\n   * @param value The IRI for the named node.\n   * @return A new instance of NamedNode.\n   * @see NamedNode\n   */\n  public namedNode<Iri extends string = string>(value: Iri): NamedNode<Iri> {\n    return new NamedNode(value);\n  }\n\n  /**\n   * @param value The optional blank node identifier.\n   * @return A new instance of BlankNode.\n   *         If the `value` parameter is undefined a new identifier\n   *         for the blank node is generated for each call.\n   * @see BlankNode\n   */\n  public blankNode(value?: string): BlankNode {\n    return new BlankNode(value || `${this.blankNodePrefix}${this.blankNodeCounter++}`);\n  }\n\n  /**\n   * @param value              The literal value.\n   * @param languageOrDatatype The optional language or datatype.\n   *                           If `languageOrDatatype` is a NamedNode,\n   *                           then it is used for the value of `NamedNode.datatype`.\n   *                           Otherwise `languageOrDatatype` is used for the value\n   *                           of `NamedNode.language`.\n   * @return A new instance of Literal.\n   * @see Literal\n   */\n  public literal(value: string, languageOrDatatype?: string | RDF.NamedNode): Literal {\n    return new Literal(value, languageOrDatatype);\n  }\n\n  /**\n   * This method is optional.\n   * @param value The variable name\n   * @return A new instance of Variable.\n   * @see Variable\n   */\n  public variable(value: string): Variable {\n    return new Variable(value);\n  }\n\n  /**\n   * @return An instance of DefaultGraph.\n   */\n  public defaultGraph(): DefaultGraph {\n    return DefaultGraph.INSTANCE;\n  }\n\n  /**\n   * @param subject   The quad subject term.\n   * @param predicate The quad predicate term.\n   * @param object    The quad object term.\n   * @param graph     The quad graph term.\n   * @return A new instance of Quad.\n   * @see Quad\n   */\n  public quad(\n    subject: Q['subject'],\n    predicate: Q['predicate'],\n    object: Q['object'],\n    graph?: Q['graph'],\n  ): Q & Quad {\n    return <Q> new Quad(subject, predicate, object, graph || this.defaultGraph());\n  }\n\n  /**\n   * Create a deep copy of the given term using this data factory.\n   * @param original An RDF term.\n   * @return A deep copy of the given term.\n   */\n  public fromTerm<T extends RDF.Term>(original: T):\n  (T extends RDF.NamedNode ? NamedNode\n    : (T extends RDF.BlankNode ? BlankNode\n      : (T extends RDF.Literal ? Literal\n        : (T extends RDF.Variable ? Variable\n          : (T extends RDF.DefaultGraph ? DefaultGraph\n            : (T extends Q ? Q : unknown)))))) {\n    // TODO: remove nasty any casts when this TS bug has been fixed:\n    //  https://github.com/microsoft/TypeScript/issues/26933\n    switch (original.termType) {\n      case 'NamedNode':\n        return <any> this.namedNode(original.value);\n      case 'BlankNode':\n        return <any> this.blankNode(original.value);\n      case 'Literal':\n        if ((<RDF.Literal> original).language) {\n          return <any> this.literal(original.value, (<RDF.Literal>original).language);\n        }\n        if (!(<RDF.Literal> original).datatype.equals(Literal.XSD_STRING)) {\n          return <any> this.literal(original.value, this.fromTerm((<RDF.Literal> original).datatype));\n        }\n        return <any> this.literal(original.value);\n      case 'Variable':\n        return <any> this.variable(original.value);\n      case 'DefaultGraph':\n        return <any> this.defaultGraph();\n      case 'Quad':\n        return <any> this.quad(\n          <Q['subject']> this.fromTerm((<Q> <unknown> original).subject),\n          <Q['predicate']> this.fromTerm((<Q> <unknown> original).predicate),\n          <Q['object']> this.fromTerm((<Q> <unknown> original).object),\n          <Q['graph']> this.fromTerm((<Q> <unknown> original).graph),\n        );\n    }\n  }\n\n  /**\n   * Create a deep copy of the given quad using this data factory.\n   * @param original An RDF quad.\n   * @return A deep copy of the given quad.\n   */\n  public fromQuad(original: Q): Q {\n    return <Q> this.fromTerm(original);\n  }\n\n  /**\n   * Reset the internal blank node counter.\n   */\n  public resetBlankNodeCounter(): void {\n    this.blankNodeCounter = 0;\n  }\n}\n\nexport interface IDataFactoryOptions {\n  blankNodePrefix?: string;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}