{"ast":null,"code":"import { Node, mergeAttributes, nodeInputRule } from '@tiptap/core';\nimport { TextSelection } from 'prosemirror-state';\nvar HorizontalRule = Node.create({\n  name: 'horizontalRule',\n  addOptions: function addOptions() {\n    return {\n      HTMLAttributes: {}\n    };\n  },\n  group: 'block',\n  parseHTML: function parseHTML() {\n    return [{\n      tag: 'hr'\n    }];\n  },\n  renderHTML: function renderHTML(_ref) {\n    var HTMLAttributes = _ref.HTMLAttributes;\n    return ['hr', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes)];\n  },\n  addCommands: function addCommands() {\n    var _this = this;\n    return {\n      setHorizontalRule: function setHorizontalRule() {\n        return function (_ref2) {\n          var chain = _ref2.chain;\n          return chain().insertContent({\n            type: _this.name\n          })\n          // set cursor after horizontal rule\n          .command(function (_ref3) {\n            var tr = _ref3.tr,\n              dispatch = _ref3.dispatch;\n            var _a;\n            if (dispatch) {\n              var $to = tr.selection.$to;\n              var posAfter = $to.end();\n              if ($to.nodeAfter) {\n                tr.setSelection(TextSelection.create(tr.doc, $to.pos));\n              } else {\n                // add node after horizontal rule if it’s the end of the document\n                var node = (_a = $to.parent.type.contentMatch.defaultType) === null || _a === void 0 ? void 0 : _a.create();\n                if (node) {\n                  tr.insert(posAfter, node);\n                  tr.setSelection(TextSelection.create(tr.doc, posAfter));\n                }\n              }\n              tr.scrollIntoView();\n            }\n            return true;\n          }).run();\n        };\n      }\n    };\n  },\n  addInputRules: function addInputRules() {\n    return [nodeInputRule({\n      find: /^(?:---|—-|___\\s|\\*\\*\\*\\s)$/,\n      type: this.type\n    })];\n  }\n});\nexport { HorizontalRule, HorizontalRule as default };","map":{"version":3,"sources":["../src/horizontal-rule.ts"],"names":[],"mappings":";;AAsBa,IAAA,cAAc,GAAG,IAAI,CAAC,MAAM,CAAwB;EAC/D,IAAI,EAAE,gBAAgB;EAEtB,UAAU,wBAAA;IACR,OAAO;MACL,cAAc,EAAE,CAAA;KACjB;GACF;EAED,KAAK,EAAE,OAAO;EAEd,SAAS,uBAAA;IACP,OAAO,CACL;MAAE,GAAG,EAAE;IAAI,CAAE,CACd;GACF;EAED,UAAU,4BAAmB;IAAA,IAAhB,cAAc,QAAd,cAAc;IACzB,OAAO,CAAC,IAAI,EAAE,eAAe,CAAC,IAAI,CAAC,OAAO,CAAC,cAAc,EAAE,cAAc,CAAC,CAAC;GAC5E;EAED,WAAW,yBAAA;IAAA;IACT,OAAO;MACL,iBAAiB,EAAE;QAAA,OAAM,iBAAc;UAAA,IAAX,KAAK,SAAL,KAAK;UAC/B,OAAO,KAAK,EAAE,CACX,aAAa,CAAC;YAAE,IAAI,EAAE,KAAI,CAAC;UAAI,CAAE;;WAEjC,OAAO,CAAC,iBAAqB;YAAA,IAAlB,EAAE,SAAF,EAAE;cAAE,QAAQ,SAAR,QAAQ;;YACtB,IAAI,QAAQ,EAAE;cACZ,IAAQ,GAAG,GAAK,EAAE,CAAC,SAAS,CAApB,GAAG;cACX,IAAM,QAAQ,GAAG,GAAG,CAAC,GAAG,EAAE;cAE1B,IAAI,GAAG,CAAC,SAAS,EAAE;gBACjB,EAAE,CAAC,YAAY,CAAC,aAAa,CAAC,MAAM,CAAC,EAAE,CAAC,GAAG,EAAE,GAAG,CAAC,GAAG,CAAC,CAAC;cACvD,CAAA,MAAM;;gBAEL,IAAM,IAAI,GAAG,CAAA,EAAA,GAAA,GAAG,CAAC,MAAM,CAAC,IAAI,CAAC,YAAY,CAAC,WAAW,MAAE,IAAA,IAAA,EAAA,KAAA,KAAA,CAAA,GAAA,KAAA,CAAA,GAAA,EAAA,CAAA,MAAM,EAAE;gBAE/D,IAAI,IAAI,EAAE;kBACR,EAAE,CAAC,MAAM,CAAC,QAAQ,EAAE,IAAI,CAAC;kBACzB,EAAE,CAAC,YAAY,CAAC,aAAa,CAAC,MAAM,CAAC,EAAE,CAAC,GAAG,EAAE,QAAQ,CAAC,CAAC;gBACxD;cACF;cAED,EAAE,CAAC,cAAc,EAAE;YACpB;YAED,OAAO,IAAI;UACb,CAAC,CAAC,CACD,GAAG,EAAE;SACT;MAAA;KACF;GACF;EAED,aAAa,2BAAA;IACX,OAAO,CACL,aAAa,CAAC;MACZ,IAAI,EAAE,6BAA6B;MACnC,IAAI,EAAE,IAAI,CAAC;KACZ,CAAC,CACH;EACF;AACF,CAAA,CAAA","sourcesContent":["import {\n  mergeAttributes,\n  Node,\n  nodeInputRule,\n} from '@tiptap/core'\nimport { TextSelection } from 'prosemirror-state'\n\nexport interface HorizontalRuleOptions {\n  HTMLAttributes: Record<string, any>,\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    horizontalRule: {\n      /**\n       * Add a horizontal rule\n       */\n      setHorizontalRule: () => ReturnType,\n    }\n  }\n}\n\nexport const HorizontalRule = Node.create<HorizontalRuleOptions>({\n  name: 'horizontalRule',\n\n  addOptions() {\n    return {\n      HTMLAttributes: {},\n    }\n  },\n\n  group: 'block',\n\n  parseHTML() {\n    return [\n      { tag: 'hr' },\n    ]\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return ['hr', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes)]\n  },\n\n  addCommands() {\n    return {\n      setHorizontalRule: () => ({ chain }) => {\n        return chain()\n          .insertContent({ type: this.name })\n          // set cursor after horizontal rule\n          .command(({ tr, dispatch }) => {\n            if (dispatch) {\n              const { $to } = tr.selection\n              const posAfter = $to.end()\n\n              if ($to.nodeAfter) {\n                tr.setSelection(TextSelection.create(tr.doc, $to.pos))\n              } else {\n                // add node after horizontal rule if it’s the end of the document\n                const node = $to.parent.type.contentMatch.defaultType?.create()\n\n                if (node) {\n                  tr.insert(posAfter, node)\n                  tr.setSelection(TextSelection.create(tr.doc, posAfter))\n                }\n              }\n\n              tr.scrollIntoView()\n            }\n\n            return true\n          })\n          .run()\n      },\n    }\n  },\n\n  addInputRules() {\n    return [\n      nodeInputRule({\n        find: /^(?:---|—-|___\\s|\\*\\*\\*\\s)$/,\n        type: this.type,\n      }),\n    ]\n  },\n})\n"]},"metadata":{},"sourceType":"module"}